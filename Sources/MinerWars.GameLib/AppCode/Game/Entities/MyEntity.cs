using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using KeenSoftwareHouse.Library.Collections;
using MinerWarsMath;
using MinerWars.AppCode.App;
using MinerWars.AppCode.Game.Audio;
using MinerWars.AppCode.Game.Decals;
using MinerWars.AppCode.Game.Editor;
using MinerWars.AppCode.Game.Gameplay;
using MinerWars.AppCode.Game.GUI;
using MinerWars.AppCode.Game.HUD;
using MinerWars.AppCode.Game.Managers.EntityManager.Notifications;
using MinerWars.AppCode.Game.Managers.Session;
using MinerWars.AppCode.Game.Missions;
using MinerWars.AppCode.Game.Models;
using MinerWars.AppCode.Game.Physics;
using MinerWars.AppCode.Game.Radar;
using MinerWars.AppCode.Game.Render;
using MinerWars.AppCode.Game.Sessions;
using MinerWars.AppCode.Game.TransparentGeometry;
using MinerWars.AppCode.Physics;
using MinerWars.AppCode.Physics.Collisions;
using MinerWars.CommonLIB.AppCode.Networking;
using MinerWars.CommonLIB.AppCode.Networking.Multiplayer;
using MinerWars.CommonLIB.AppCode.Utils;

using SysUtils;
using SysUtils.Utils;
using MinerWars.AppCode.Game.Managers;
using MinerWars.AppCode.Game.Utils;
using MinerWars.CommonLIB.AppCode.ObjectBuilders;
using MinerWars.CommonLIB.AppCode.ObjectBuilders.Object3D;
using MinerWars.CommonLIB.AppCode.Import;

namespace MinerWars.AppCode.Game.Entities
{
    /// <summary>
    /// Enumeration flags
    /// </summary>
    [Flags]
    public enum EnumerationFlags
    {
        /// <summary>
        /// No flags
        /// </summary>
        None = 1 << 0,

        /// <summary>
        /// Enumerate also all sub-children.
        /// </summary>
        Hierarchically = 1 << 1,
    }

    delegate void DieHandler(MyEntity entity, MyEntity killer);

    /// <summary>
    /// Abstract engine entity object representing non-mass point object in space.
    /// Resources can extend this object and give it purpose. Game entities inherites directly from this class.
    /// </summary>
    internal abstract class MyEntity : MyResource, IMyEditableEntity, IMyNotifyEntityChanged, IMyObjectToDetect, IMyHasFaction
    {
        #region Enums

        /// <summary>
        /// Entity flags.
        /// </summary>
        [Flags]
        public enum EntityFlags
        {
            /// <summary>
            /// No flags
            /// </summary>
            None = 1 << 0,

            /// <summary>
            /// Specified that position changed and all dependent values should be recalculated.
            /// </summary>
            PositionDirty = 1 << 1,

            /// <summary>
            /// Specifies that volume is dirty and should be recalculated in parents.
            /// </summary>
            VolumeDirty = 1 << 2,

            /// <summary>
            /// Draw also all chidren of this entity.
            /// Temporary flag. Removed because everybody children are drawn individually
            /// </summary>
            //DrawChildren = 1 << 3,

            /// <summary>
            /// Specifies whether draw this entity or not.
            /// </summary>
            Visible = 1 << 4,

            /// <summary>
            /// Specifies whether draw this entity in game  or not.
            /// </summary>
            VisibleInGame = 1 << 5,

            /// <summary>
            /// Specified whether entity need entity id (for example SmallDebris needs no EntityId)
            /// </summary>
            NeedsId = 1 << 6,

            /// <summary>
            /// Specifies whether save entity when saving sector or not
            /// </summary>
            Save = 1 << 7,

            /// <summary>
            /// Specifies whether entity is "near", near entities are cockpit and weapons, these entities are rendered in special way
            /// </summary>
            Near = 1 << 8,

            /// <summary>
            /// Entity is editable object in editor. Used for statistics
            /// </summary>
            EditableInEditor = 1 << 9,

            /// <summary>
            /// On this entity and its children will be called UpdateBeforeSimulation and UpdateAfterSimulation each frame
            /// </summary>
            NeedsUpdate = 1 << 10,

            /// <summary>
            /// This entity is generated by SectorGenerator, it will be not saved 
            /// </summary>
            Generated = 1 << 11,

            /// <summary>
            /// When entity is hit by explosion, it will check for obstacles (eg. entity can hide from explosion behind corner)
            /// </summary>
            CheckExplosionObstacles = 1 << 12,

            /// <summary>
            /// Shows entity on HUD only when detected by radar
            /// </summary>
            ShowOnHudOnlyWhenDetected = 1 << 13,
        }

        #endregion

        #region Constants
        private const MyPersistentEntityFlags ACTIVATED_DIFFICULTY_EASY = MyPersistentEntityFlags.ActivatedOnDifficultyEasy;
        private const MyPersistentEntityFlags ACTIVATED_DIFFICULTY_NORMAL = ACTIVATED_DIFFICULTY_EASY | MyPersistentEntityFlags.ActivatedOnDifficultyNormal;
        private const MyPersistentEntityFlags ACTIVATED_DIFFICULTY_HARD = ACTIVATED_DIFFICULTY_NORMAL | MyPersistentEntityFlags.ActivatedOnDifficultyHard;
        #endregion

        #region Fields

        /// <summary>
        /// Internal world matrix of entity.
        /// </summary>
        private Matrix m_worldMatrix;

        /// <summary>
        /// Internal local matrix relative to parent of entity.
        /// </summary>
        private Matrix m_localMatrix;

        /// <summary>
        /// Gets the childs collection.
        /// </summary>
        private readonly ObservableCollection<MyEntity> m_children;

        /// <summary>
        /// Currently means that entity was added into MyEntities list
        /// </summary>
        protected bool m_activated = false;

        //Bounding boxes
        protected BoundingBox m_localAABB;   //untransformed aabb of this entity (mostly LOD0 model) 
        protected BoundingSphere m_localVolume;   //untransformed sphere of this entity (mostly LOD0 model) 
        protected Vector3 m_localVolumeOffset;
        protected BoundingBox m_worldAABB;   //world AABB of this entity
        protected BoundingSphere m_worldVolume;   //sphere volume
        private BoundingBox m_worldAABBHr;   //world AABB of this entity including children
        private BoundingSphere m_worldVolumeHr;   //sphere volume including children

        private MyMwcObjectBuilder_Base m_objectBuilder; // Object builder is the template this object was created from and is saved as

        //Rendering
        protected MyModel m_modelLod0;                       //  LOD0 main model, used for rendering and also physics / col-det
        protected MyModel m_modelLod1;                       //  LOD1 version of this model, used only for rendering (not physics and col-det)
        protected MyModel m_modelLod2;                       //  LOD2 version of this model, used only for rendering (not physics and col-det)
        protected MyModel m_modelCollision;                       //  Collision model, used only for collisions
        protected bool m_frustumCheckBeforeDrawEnabled = true; //  If true, we always check if this phys object is contained in frustum. If false we don't check and draw it directly (which is faster for small-low-face objects)
        protected Vector3? m_diffuseColor;  //diffuse color multiplier
        protected Vector3 m_highlightColor; //used for objects that are selected in editor(shader adds this color to pixel shader output)
        protected Vector4 m_mouseOverColorWire = new Vector4(0.5f, 1f, 0.5f, 0.5f);
        protected Vector4 m_mouseOverColor = new Vector4(0.9f, 0.8f, 0.5f, 0.3f);
        protected Vector3 m_selectionHighlightColor;
        protected Vector3 m_collisionHighlightColor;
        protected float? m_lod1ForcedDistance;
        protected bool m_enableEmissivity = true;

        //  Textures
        MyMwcVoxelMaterialsEnum m_voxelMaterial;
        public virtual MyMwcVoxelMaterialsEnum VoxelMaterial
        {
            get
            {
                return m_voxelMaterial;
            }
            set
            {
                m_voxelMaterial = value;
            }
        }


        protected MyRenderObject[] m_renderObjects;

        //Space query structure
        public int GamePruningProxyId = MyConstants.GAME_PRUNING_STRUCTURE_PROXY_ID_NOT_INSERTED;

        //Gameplay
        protected MyGameplayProperties m_gameplayProperties;
        private float? m_maxHealth;
        private float m_healthRatio;
        //protected float m_health;
                
        protected bool m_wasDead;
        protected bool m_isExploded;

        #endregion

        #region Properties

        /// <summary>
        /// Entity id, can be set by subclasses (for example when using pool...)
        /// </summary>
        public MyEntityIdentifier? EntityId { get; set; }

        public bool IsDummy;

        /// <summary>
        /// Priority for AI, ie. when bot is selecting target for attack it will select entity with highest priority
        /// </summary>
        public int AIPriority { get; set; }

        public bool IsHologram { get; set; }

        //public float Channel0Intensity { get { return MyRender.Channel0Intensity; } }
        //public float Channel1Intensity { get { return MyRender.Channel1Intensity; } }

        public bool Closed { get; protected set; }

        private bool m_visibleFromSun;
        private int m_visibleFromSunNextCheck;

        public bool IsVisibleFromSun
        {
            get
            {
                if (MyMinerGame.TotalGamePlayTimeInMilliseconds > m_visibleFromSunNextCheck)
                {
                    UpdateVisibleFromSun();
                }

                return m_visibleFromSun;
            }
        }

        private void UpdateVisibleFromSun()
        {
            MyPerformanceCounter.PerCameraDraw.Increment("Updated sun visibility");
            MyLine line = new MyLine(GetPosition(), GetPosition() + MyGuiScreenGamePlay.Static.GetDirectionToSunNormalized() * MyMwcSectorConstants.SECTOR_DIAMETER, true);
            m_visibleFromSun = !MyEntities.GetAnyIntersectionWithLine_IgnoreOtherThanSpecifiedClass(ref line, MySunWind.DoNotIgnoreTheseTypes);

            int checkInterval = MyConstants.VISIBLE_FROM_SUN_MIN_CHECK_INTERVAL.Milliseconds;
            m_visibleFromSunNextCheck = MyMinerGame.TotalGamePlayTimeInMilliseconds + MyMwcUtils.GetRandomInt(checkInterval, checkInterval + checkInterval / 3);
        }

        /// <summary>
        /// World matrix of this physic object. Use it whenever you want to do world-matrix transformations with this physic objects.
        /// </summary>
        public Matrix WorldMatrix
        {
            get { return this.m_worldMatrix; }
            set { SetWorldMatrix(value); }
        }

        public bool Save
        {
            get
            {
                return (Flags & EntityFlags.Save) != 0 && !IsGenerated;
            }
            set
            {
                if (value)
                    Flags |= EntityFlags.Save;
                else
                    Flags &= ~EntityFlags.Save;
            }
        }

        public virtual bool NearFlag
        {
            get
            {
                return (Flags & EntityFlags.Near) != 0;
            }
            set
            {
                bool hasChanged = value != NearFlag;

                if (value)
                    Flags |= EntityFlags.Near;
                else
                    Flags &= ~EntityFlags.Near;


                if (RenderObjects != null && hasChanged)
                {
                    UpdateRenderObject(false); // Remove (because we need to remove from one group)
                    UpdateRenderObject(true); // And insert again (...and insert into another)
                }

                // Update children near flag
                foreach (var c in Children)
                {
                    c.NearFlag = value;
                }
            }
        }


        public bool NeedsUpdate
        {
            get
            {
                return (Flags & EntityFlags.NeedsUpdate) != 0;
            }
            set
            {
                bool hasChanged = value != NeedsUpdate;

                if (value)
                    Flags |= EntityFlags.NeedsUpdate;
                else
                    Flags &= ~EntityFlags.NeedsUpdate;


                if (hasChanged && value)
                {
                    MyEntities.RegisterForUpdate(this);
                }
                else
                    if (hasChanged && !value)
                    {
                        MyEntities.UnregisterForUpdate(this);
                    }
            }
        }

        public bool IsGenerated
        {
            get
            {
                return (Flags & EntityFlags.Generated) != 0;
            }
            set
            {
                if (value)
                    Flags |= EntityFlags.Generated;
                else
                    Flags &= ~EntityFlags.Generated;
            }
        }

        public bool ShowOnHudOnlyWhenDetected
        {
            get
            {
                return (Flags & EntityFlags.ShowOnHudOnlyWhenDetected) != 0;
            }
            set
            {
                if (value)
                    Flags |= EntityFlags.ShowOnHudOnlyWhenDetected;
                else
                    Flags &= ~EntityFlags.ShowOnHudOnlyWhenDetected;
            }
        }

        public bool CastShadows
        {
            get
            {
                return (PersistentFlags & MyPersistentEntityFlags.CastShadows) != 0;
            }
            set
            {
                if (value)
                {
                    PersistentFlags |= MyPersistentEntityFlags.CastShadows;

                    if (RenderObjects != null)
                    {
                        foreach (var renderObject in RenderObjects)
                        {
                            MyRender.AddShadowRenderObject(renderObject);
                        }
                    }
                }
                else
                {
                    PersistentFlags &= ~MyPersistentEntityFlags.CastShadows;

                    if (RenderObjects != null)
                    {
                        foreach (var renderObject in RenderObjects)
                        {
                            MyRender.RemoveShadowRenderObject(renderObject);
                        }
                    }
                }
            }
        }

        public bool UseKinematicPhysics
        {
            get
            {
                return (PersistentFlags & MyPersistentEntityFlags.KinematicPhysics) != 0;
            }
            set
            {
                if (value)
                {
                    PersistentFlags |= MyPersistentEntityFlags.KinematicPhysics;
                }
                else
                {
                    PersistentFlags &= ~MyPersistentEntityFlags.KinematicPhysics;
                }
            }
        }


        public virtual bool Enabled
        {
            get
            {
                return (PersistentFlags & MyPersistentEntityFlags.Enabled) != 0 && Activated;
            }
            set
            {
                if (value)
                {
                    PersistentFlags |= MyPersistentEntityFlags.Enabled;
                }
                else
                {
                    PersistentFlags &= (~MyPersistentEntityFlags.Enabled);
                }
            }
        }

        public bool IsSecret
        {
            get
            {
                return (PersistentFlags & MyPersistentEntityFlags.Secret) != 0;
            }
            set
            {
                if (value)
                    PersistentFlags |= MyPersistentEntityFlags.Secret;
                else
                    PersistentFlags &= ~MyPersistentEntityFlags.Secret;
            }
        }

        /// <summary>
        /// Gets or sets the local matrix.
        /// </summary>
        /// <value>
        /// The local matrix.
        /// </value>
        public Matrix LocalMatrix
        {
            get { return this.m_localMatrix; }
            set { SetLocalMatrix(value); }
        }

        /// <summary>
        /// Gets the world aabb.
        /// </summary>
        public BoundingBox WorldAABB
        {
            get { return m_worldAABB; }
        }

        /// <summary>
        /// Gets the world volume.
        /// </summary>
        public BoundingSphere WorldVolume
        {
            get { return m_worldVolume; }
        }

        /// <summary>
        /// Gets the hiearchical box in world.
        /// </summary>
        public BoundingBox WorldAABBHr
        {
            get
            {
                return m_worldAABBHr;
            }
        }

        /// <summary>
        /// Gets the hiearchical volume in world.
        /// </summary>
        public BoundingSphere WorldVolumeHr
        {
            get
            {
                return m_worldVolumeHr;
            }
        }

        /// <summary>
        /// Sets the local aabb.
        /// </summary>
        /// <value>
        /// The local aabb.
        /// </value>
        public BoundingBox LocalAABB
        {
            get
            {
                return m_localAABB;
            }
            set
            {
                m_localAABB = value;
                m_localVolume = BoundingSphere.CreateFromBoundingBox(m_localAABB);
                UpdateWorldVolume();
            }
        }

        /// <summary>
        /// Sets the local volume.
        /// </summary>
        /// <value>
        /// The local volume.
        /// </value>
        public BoundingSphere LocalVolume
        {
            get
            {
                return m_localVolume;
            }
            set
            {
                m_localVolume = value;
                m_localAABB = MyMath.CreateFromInsideRadius(value.Radius);
                m_localAABB = m_localAABB.Translate(value.Center);
                UpdateWorldVolume();
            }
        }


        /// <summary>
        /// Gets or sets the local volume offset.
        /// </summary>
        /// <value>
        /// The local volume offset.
        /// </value>
        public Vector3 LocalVolumeOffset
        {
            get
            {
                return this.m_localVolumeOffset;
            }
            set
            {
                this.m_localVolumeOffset = value;
                UpdateWorldVolume();
            }
        }

        /// <summary>
        /// Gets or sets the parent.
        /// </summary>
        /// <value>
        /// The parent.
        /// </value>
        public MyEntity Parent { get; private set; }

        /// <summary>
        /// Return top most parent of this entity
        /// </summary>
        /// <returns></returns>
        public MyEntity GetTopMostParent(Type type = null)
        {
            MyEntity parent = this;

            while (parent.Parent != null && (type == null || !parent.GetType().IsSubclassOf(type)))
            {
                parent = parent.Parent;
            }

            return parent;
        }

        /// <summary>
        /// Gets the childs collection.
        /// </summary>
        //[Remoting(Controller)]
        public ObservableCollection<MyEntity> Children
        {
            get
            {
                return this.m_children;
            }
        }

        /// <summary>
        /// Gets the physic body representation of the entity.
        /// </summary>
        public MyPhysicsBody Physics { get; internal set; }

        /// <summary>
        /// Gets the graphics representation of entity.
        /// </summary>
        public int Graphics { get; internal set; }

        /// <summary>
        /// Gets the sound representation of entity.
        /// </summary>
        public int Sound { get; internal set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref="MyEntity"/> is visible.
        /// </summary>
        /// <value>
        ///   <c>true</c> if visible; otherwise, <c>false</c>.
        /// </value>
        public bool Visible
        {
            get
            {
                return (Flags & EntityFlags.Visible) != 0;
            }

            set
            {
                Debug.Assert(!Closed, "Cannot change visibility, entity is closed");

                EntityFlags oldValue = Flags;

                if (value)
                {
                    Flags = Flags | EntityFlags.Visible;
                }
                else
                {
                    Flags = Flags & (~EntityFlags.Visible);
                }

                if (oldValue != Flags)
                {
                    UpdateRenderObject(value);
                }
            }
        }
        
        public bool DisplayOnHud
        {
            get
            {
                return (PersistentFlags & MyPersistentEntityFlags.DisplayOnHud) != 0;
            }
            set
            {
                if (value != DisplayOnHud) 
                {
                    if (value)
                    {
                        PersistentFlags |= MyPersistentEntityFlags.DisplayOnHud;                        
                    }
                    else 
                    {
                        PersistentFlags &= ~MyPersistentEntityFlags.DisplayOnHud;                        
                    }
                    UpdateHudMarker();
                }
            }
        }

        private MyPersistentEntityFlags GetFlagsForDifficulty(MyGameplayDifficultyEnum difficulty) 
        {                        
            switch(difficulty)
            {
                case MyGameplayDifficultyEnum.EASY:
                    return ACTIVATED_DIFFICULTY_EASY;
                case MyGameplayDifficultyEnum.NORMAL:
                    return ACTIVATED_DIFFICULTY_NORMAL;
                case MyGameplayDifficultyEnum.HARD:
                    return ACTIVATED_DIFFICULTY_HARD;
            }
            throw new MyMwcExceptionApplicationShouldNotGetHere();
        }

        public bool IsActivatedForDifficulty(MyGameplayDifficultyEnum difficulty) 
        {
            MyPersistentEntityFlags flagsForDifficulty = GetFlagsForDifficulty(difficulty);
            return (PersistentFlags & flagsForDifficulty) == flagsForDifficulty;
        }                

        public MyGameplayDifficultyEnum MaxDifficultyToActivated 
        {
            get 
            {
                if (IsActivatedForDifficulty(MyGameplayDifficultyEnum.HARD))
                {
                    return MyGameplayDifficultyEnum.HARD;
                }
                else if (IsActivatedForDifficulty(MyGameplayDifficultyEnum.NORMAL))
                {
                    return MyGameplayDifficultyEnum.NORMAL;
                }
                else if (IsActivatedForDifficulty(MyGameplayDifficultyEnum.EASY))
                {
                    return MyGameplayDifficultyEnum.EASY;
                }
                throw new MyMwcExceptionApplicationShouldNotGetHere();
            }
            set 
            {
                PersistentFlags &= ~GetFlagsForDifficulty(MyGameplayDifficultyEnum.HARD);
                PersistentFlags |= GetFlagsForDifficulty(value);
            }
        }

        public bool Activated
        {
            get
            {
                bool activated = !((PersistentFlags & MyPersistentEntityFlags.Deactivated) != 0);
                if (MyGuiScreenGamePlay.Static != null && MyGuiScreenGamePlay.Static.IsGameStoryActive())
                {
                    activated &= IsActivatedForDifficulty(MyGameplayConstants.GameplayDifficultyProfile.GameplayDifficulty);
                }
                return activated;
                //return !((PersistentFlags & MyPersistentEntityFlags.Deactivated) != 0);
            }
        }

        public void Activate(bool activate, bool buffered = true)
        {
            Debug.Assert(!Closed, "Cannot change visibility, entity is closed");

            if (buffered)
            {
                if (activate)
                    MyEntities.ActivateBuffered(this);
                else
                    MyEntities.DeactivateBuffered(this);

                foreach (MyEntity child in Children)
                {
                    child.Activate(activate, buffered);
                }
            }
            else
            {
                MyPersistentEntityFlags oldValue = PersistentFlags;

                if (!activate)
                {
                    PersistentFlags = PersistentFlags | MyPersistentEntityFlags.Deactivated;
                }
                else
                {
                    PersistentFlags = PersistentFlags & (~MyPersistentEntityFlags.Deactivated);
                }

                if (oldValue != PersistentFlags)
                {
                    if (activate)
                    {
                        OnActivated(null);
                        if (NeedsUpdate)
                            MyEntities.RegisterForUpdate(this);
                    }
                    else
                    {
                        OnDeactivated(null);
                        MyEntities.UnregisterForUpdate(this);
                    }

                    foreach (MyEntity child in Children)
                    {
                        child.Activate(activate, buffered);
                    }
                }
            }
        }

        protected virtual void InitRenderObjects()
        {
            m_renderObjects = new MyRenderObject[] { new MyRenderObject(this, null) };
        }

        protected virtual void AddRenderObjects()
        {
            MyRender.AddRenderObject(RenderObjects[0]);
        }

        protected virtual void RemoveRenderObjects()
        {
            MyRender.RemoveRenderObject(RenderObjects[0]);
        }

        protected void UpdateRenderObject(bool visible)
        {
            if (!Activated && visible)
                return;

            if (visible)
            {
                if (Visible && (Parent == null || Parent.Visible) && m_frustumCheckBeforeDrawEnabled)
                {
                    if (CanBeAddedToRender())
                    {
                        AddRenderObjects();    
                    }
                }
            }
            else
            {
                if (RenderObjects != null)
                {
                    RemoveRenderObjects();
                }
            }

            foreach (MyEntity child in Children)
            {
                child.UpdateRenderObject(visible);
            }
        }

        public void UpdateGamePruningStructure()
        {
            MyGamePruningStructure.Move(this);
            foreach (MyEntity child in Children) child.UpdateGamePruningStructure();
        }

        public void AddToGamePruningStructure()
        {
            MyGamePruningStructure.Add(this);
            foreach (MyEntity child in Children) child.AddToGamePruningStructure();
        }

        public void RemoveFromGamePruningStructure()
        {
            MyGamePruningStructure.Remove(this);
            foreach (MyEntity child in Children) child.RemoveFromGamePruningStructure();
        }

        static public void ClearGamePruningStructure()
        {
            MyGamePruningStructure.Clear();
        }
    
        protected virtual bool CanBeAddedToRender()
        {
            return true;
        }

        public bool VisibleInGame
        {
            get
            {
                return (Flags & EntityFlags.VisibleInGame) != 0;
            }

            set
            {
                if (value)
                {
                    Flags = Flags | EntityFlags.VisibleInGame;
                }
                else
                {
                    Flags = Flags & (~EntityFlags.VisibleInGame);
                }
            }
        }

        /// <summary>
        /// Gets or sets the entity flags.
        /// </summary>
        /// <value>
        /// The flags.
        /// </value>
        public EntityFlags Flags { get; set; }
        public MyPersistentEntityFlags PersistentFlags { get; set; }


        protected bool NeedsId
        {
            get
            {
                return (Flags & EntityFlags.NeedsId) != 0;
            }
        }

        public bool CheckExplosionObstacles
        {
            get
            {
                return (Flags & EntityFlags.CheckExplosionObstacles) != 0;
            }
            protected set
            {
                if (value)
                {
                    Flags |= EntityFlags.CheckExplosionObstacles;
                }
                else
                {
                    Flags &= ~EntityFlags.CheckExplosionObstacles;
                }
            }
        }

        public Vector3? GetDiffuseColor() { return m_diffuseColor; }
        public Vector3 GetHighlightColor() { return m_highlightColor; }
        private void SetDiffuseColor(ref Vector3 vctColor) { m_diffuseColor = vctColor; }
        private void SetHighlightColor(Vector3 vctColor)
        {
            if (MyMwcFinalBuildConstants.ENABLE_OBJECT_HIGHLIGHT)
            {
                m_highlightColor = vctColor;
            }
        }

        public MyModel ModelLod0
        {
            get { return m_modelLod0; }
        }

        public MyModel ModelLod1
        {
            get { return m_modelLod1; }
        }

        public MyModel ModelLod2
        {
            get { return m_modelLod2; }
        }

        public float? Lod1ForcedDistance
        {
            get { return m_lod1ForcedDistance; }
        }

        public MyModel ModelCollision
        {
            get
            {
                if (m_modelCollision != null)
                {
                    return m_modelCollision;
                }
                else
                    return m_modelLod0;
            }
        }

        private ushort m_materialIndex;

        /// <summary>
        /// Only used by prefabs so far. Indicates the material which is used for the entity.
        /// </summary>
        public ushort MaterialIndex
        {
            get { return m_materialIndex; }
            set
            {
                MyRender.GetRenderProfiler().StartProfilingBlock("MyEntity preload Material textures");

                var modelLod0 = GetModelLod0();
                if (modelLod0 != null)
                    foreach (var mesh in modelLod0.GetMeshList())
                    {
                        if (value > mesh.Materials.Length - 1)
                        {
                            MyRender.GetRenderProfiler().EndProfilingBlock();
                            throw new MyMaterialNotAvailableException(modelLod0.AssetName, value);
                        }

                        //Let it for render
                        //mesh.Materials[value].PreloadTexture();
                    }

                var modelLod1 = GetModelLod1();
                if (modelLod1 != null)
                    foreach (var mesh in modelLod1.GetMeshList())
                    {
                        if (value > mesh.Materials.Length - 1)
                        {
                            MyRender.GetRenderProfiler().EndProfilingBlock();
                            throw new MyMaterialNotAvailableException(modelLod1.AssetName, value);
                        }

                        //Let it for render
                        //mesh.Materials[value].PreloadTexture();
                    }

                m_materialIndex = value;

                MyRender.GetRenderProfiler().EndProfilingBlock();
            }
        }

        /// <summary>
        /// Gets or sets the faction.
        /// </summary>
        /// <value>
        /// The faction.
        /// </value>
        protected MyMwcObjectBuilder_FactionEnum m_faction;
        public virtual MyMwcObjectBuilder_FactionEnum Faction
        {
            get { return m_faction; }
            set { m_faction = value; }
        }

        public MyRenderObject[] RenderObjects
        {
            get { return m_renderObjects; }
        }

        private string m_displayName;
        public string DisplayName
        {
            get
            {
                return m_displayName;
            }
            set
            {
                m_displayName = value;
                if (MyHud.ContainsEntity(this))
                {
                    MyHud.RenameHudEntity(this, new StringBuilder(GetCorrectDisplayName()));
                }
            }
        }

        public virtual string GetCorrectDisplayName()
        {
            return DisplayName;
        }


        #endregion

        #region Methods

        /// <summary>
        /// Initializes a new instance of the <see cref="MyEntity"/> class.
        /// </summary>
        protected MyEntity(bool needsId)
        {
            Faction = MyMwcObjectBuilder_FactionEnum.None;

            this.m_children = new ObservableCollection<MyEntity>();
            this.m_children.CollectionChanged += NotifyChidrenCollectionChanged;
            this.m_localMatrix = Matrix.Identity;
            this.Flags = EntityFlags.Visible | EntityFlags.VisibleInGame | EntityFlags.Save | EntityFlags.CheckExplosionObstacles;
            
            if (needsId)
            {
                this.Flags |= EntityFlags.NeedsId;
            }

            this.PersistentFlags = MyPersistentEntityFlags.Enabled | MyPersistentEntityFlags.CastShadows;

            MyScriptWrapper.OnEntityCreated(this);
        }

        protected MyEntity()
            : this(true)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        public virtual void UpdateBeforeSimulation()
        {
            Debug.Assert(!Closed, "Cannot update entity, entity is closed");

            // When somebody just set health to 0, we must handle somewhere raising OnDie events
            // Condition added to optimize (complex conditions inside)
            if (m_healthRatio <= MyGameplayConstants.HEALTH_RATIO_DEATH)
                TestDeath(null);

            //Each entity is responsible for registering for update  
            for (int i = 0; i < this.m_children.Count; i++)
            {
                this.m_children[i].UpdateBeforeSimulation();
            }
        }

        /// <summary>
        /// UpdateBeforeSimulation
        /// </summary>
        public virtual void UpdateAfterSimulation()
        {
            Debug.Assert(!Closed, "Cannot update entity, entity is closed");

            //Each entity is responsible for registering for update
            for (int i = 0; i < this.m_children.Count; i++)
            {
                this.m_children[i].UpdateAfterSimulation();
            }  
        }

        /// <summary>
        /// Collects all sub-resources of this object.
        /// </summary>
        /// <param name="collectedResources">The collected resources.</param>
        /// <param name="hierarchically"></param>
        public override void CollectResources(ICollection<MyResource> collectedResources, bool hierarchically = true)
        {
            base.CollectResources(collectedResources);

            for (int i = 0; i < this.m_children.Count; i++)
            {
                var entity = this.m_children[i];

                collectedResources.Add(entity);

                if (hierarchically)
                {
                    entity.CollectResources(collectedResources);
                }
            }

            if (this.Physics != null)
            {
                collectedResources.Add(this.Physics);

                if (hierarchically)
                {
                    this.Physics.CollectResources(collectedResources);
                }
            }
        }

        //WorldAABB
        //public virtual BoundingBox GetLocalAABB() 

        /// <summary>
        /// Generates new debug name for entity.
        /// </summary>
        [Conditional("DEBUG")]
        private void DebugGenerateEntityDisplayName()
        {
            if (this.DisplayName == null)
            {
                //Storkovina
                //this.DisplayName = string.Format("{0}:{1}", this.GetType().Name, this.GetHashCode());
                this.DisplayName = this.GetType().Name;
            }
        }

        public virtual string GetFriendlyName()
        {
            return string.Empty;
        }

        public virtual MyMeshMaterial GetMaterial(MyMesh mesh)
        {
            MyMeshMaterial material = mesh.Materials[MaterialIndex];
            material.EmissivityEnabled = m_enableEmissivity;
            //Preload needs to be here because of reloadcontent
            material.PreloadTexture(LoadingMode.Background);

            return material;
        }

        #endregion

        #region Position And Movement Methods

        /// <summary>
        /// Sets the world matrix.
        /// </summary>
        /// <param name="worldMatrix">The world matrix.</param>
        /// <param name="source">The source object that caused this change or null when not important.</param>
        public void SetWorldMatrix(Matrix worldMatrix, object source = null)
        {
            MyUtils.AssertIsValid(worldMatrix);

            if (m_scale != null)
            {
                MyMwcUtils.Normalize(ref worldMatrix, out worldMatrix);
                worldMatrix = Matrix.CreateScale(m_scale.Value) * worldMatrix;
            }

            if (this.m_worldMatrix == worldMatrix)
                return;

            if (this.Parent == null)
            {
                this.m_worldMatrix = worldMatrix;

            }
            else
            {
                Matrix matParentInv = Matrix.Invert(Parent.WorldMatrix);
                this.m_localMatrix = worldMatrix * matParentInv;

            }

            UpdateWorldMatrix(source);
        }

        /// <summary>
        /// Sets the local matrix.
        /// </summary>
        /// <param name="localMatrix">The local matrix.</param>
        /// <param name="source">The source object that caused this change or null when not important.</param>
        public void SetLocalMatrix(Matrix localMatrix, object source = null)
        {
            if (this.m_localMatrix != localMatrix)
            {
                this.m_localMatrix = localMatrix;
                UpdateWorldMatrix(source);
            }
        }

        /// <summary>
        /// Gets the entity position.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetPosition()
        {
            return this.m_worldMatrix.Translation;
        }

        /// <summary>
        /// Gets the entity direction.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetForward()
        {
            return this.m_worldMatrix.Forward;
        }

        /// <summary>
        /// Gets the entity up vector.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetUp()
        {
            return this.m_worldMatrix.Up;
        }

        /// <summary>
        /// Sets the position.
        /// </summary>
        /// <param name="pos">The pos.</param>
        public void SetPosition(Vector3 pos)
        {
            if (!MyMwcUtils.IsZero(this.m_worldMatrix.Translation - pos))
            {
                this.m_worldMatrix.Translation = pos;
                UpdateWorldMatrix();
            }
        }

        /// <summary>
        /// Scaling of this object's model. 
        /// Actualy used only for drawing and JLX collision skins. 
        /// I don't use it for line-triangleVertexes intersections in octree (but it can be added).
        /// </summary>

        float? m_scale;
        public float? Scale
        {
            get { return m_scale; }
            set
            {
                if (m_scale != value)
                {
                    m_scale = value;

                    if (m_scale != null)
                    {
                        System.Diagnostics.Debug.Assert(!MyMwcUtils.IsZero(m_scale.Value));

                        if (Parent == null)
                        {
                            MyMwcUtils.Normalize(ref m_worldMatrix, out m_worldMatrix);
                            m_worldMatrix = Matrix.CreateScale(m_scale.Value) * m_worldMatrix;
                        }
                        else
                        {
                            MyMwcUtils.Normalize(ref m_localMatrix, out m_localMatrix);
                            m_localMatrix = Matrix.CreateScale(m_scale.Value) * m_localMatrix;
                        }
                    }
                    else
                    {
                        MyMwcUtils.Normalize(ref m_localMatrix, out m_localMatrix);
                    }

                    UpdateWorldMatrix();
                }
            }
        }



        /// <summary>
        /// Gets the orientation.
        /// </summary>
        /// <returns></returns>
        public Matrix GetOrientation()
        {
            Matrix orientation = Matrix.Identity;
            orientation.Forward = WorldMatrix.Forward;
            orientation.Up = WorldMatrix.Up;
            orientation.Right = WorldMatrix.Right;
            return orientation;
        }

        /// <summary>
        /// Gets the world rotation.
        /// </summary>
        /// <returns></returns>
        [Obsolete]
        public Matrix GetWorldRotation()
        {
            var rot = Matrix.Identity;
            rot.Forward = this.WorldMatrix.Forward;
            rot.Up = this.WorldMatrix.Up;
            rot.Right = this.WorldMatrix.Right;

            return rot;
        }

        /// <summary>
        /// Inverted world matrix of this physic object calculated on-demand (non cached).
        /// Use it whenever you want to do world-matrix transformations with this physic objects.
        /// </summary>
        public Matrix GetWorldMatrixInverted()
        {
            Matrix inv;
            Matrix.Invert(ref this.m_worldMatrix, out inv);

            return inv;
        }

        /// <summary>
        /// Gets the world matrix for draw.
        /// </summary>
        /// <returns></returns>
        public virtual Matrix GetWorldMatrixForDraw()
        {
            Matrix outMatrix;
            Matrix inMatrix = this.m_worldMatrix;

            Matrix.Multiply(ref inMatrix, ref MyCamera.InversePositionTranslationMatrix, out outMatrix);

            return outMatrix;
        }

        /// <summary>
        /// Moves the and rotate.
        /// </summary>
        /// <param name="newPosition">The new position.</param>
        /// <param name="newOrientation">The new orientation.</param>
        /// <returns> return false, if object cannot be moved - this method is most important for editor and moving objects there</returns>
        public virtual bool MoveAndRotate(Vector3 newPosition, Matrix newOrientation)
        {
            newOrientation.Translation = newPosition;

            SetWorldMatrix(newOrientation);

            return true;
        }

        public virtual bool CanMoveAndRotate(Vector3 newPosition, Matrix newOrientation)
        {
            return true;
        }

        /// <summary>
        /// Resets rotation of entity to default.
        /// </summary>
        public virtual void ResetRotation()
        {
            Matrix resettedOrientation = Matrix.Identity;
            resettedOrientation.Translation = this.GetPosition();

            SetWorldMatrix(resettedOrientation);
        }

        /// <summary>
        /// Called when all entities are loaded, override to fill referenced entities.
        /// ALWAYS call base.Link(), otherwise children entities won't be linked.
        /// </summary>
        public virtual void Link()
        {
            // When needs id and has no id
            if ((this.Flags & EntityFlags.NeedsId) != 0 && !this.EntityId.HasValue)
            {
                this.EntityId = MyEntityIdentifier.AllocateId();
                MyEntityIdentifier.AddEntityWithId(this);
            }

            foreach (var child in m_children.ToList())
                child.Link();
        }

        /// <summary>
        /// Updates the world matrix (change caused by this entity)
        /// </summary>
        private void UpdateWorldMatrix(object source = null)
        {
            if (this.Parent != null)
            {
                Matrix parentWorldMatrix = this.Parent.WorldMatrix;
                UpdateWorldMatrix(ref parentWorldMatrix);

                return;
            }

            
            //UpdateWorldVolume();
            OnWorldPositionChanged(source);
            UpdateChildren(source);

            if (this.Physics != null && this.Physics.Enabled && this.Physics != source)
            {
                this.Physics.OnWorldPositionChanged(source);
            }

            // NotifyEntityChange(source);
        }

        /// <summary>
        /// Optimized version for setting up message data
        /// </summary>
        /// <param name="entity"></param>
        /// <param name="msg"></param>
        public static void FillMessage(MyEntity entity, ref MyEventUpdatePosition msg)
        {
            msg.EntityId = entity.EntityId.Value.NumericValue;
            msg.Position = new MyMwcPositionAndOrientation(ref entity.m_worldMatrix);
            msg.Velocity = entity.Physics.LinearVelocity;
            msg.Acceleration = entity.Physics.LinearAcceleration;
        }

        /// <summary>
        /// Updates the world matrix (change caused by parent)
        /// </summary>
        public virtual void UpdateWorldMatrix(ref Matrix parentWorldMatrix, object source = null)
        {
            Matrix oldWorldMatrix = m_worldMatrix;
            Matrix.Multiply(ref this.m_localMatrix, ref parentWorldMatrix, out this.m_worldMatrix);

            if (m_worldMatrix != oldWorldMatrix)
            {
                OnWorldPositionChanged(source);
                UpdateChildren(source);

                if (this.Physics != null && this.Physics.Enabled && this.Physics != source)
                {
                    this.Physics.OnWorldPositionChanged(source);
                }
            }

            //NotifyEntityChange(source);
        }

        /// <summary>
        /// Updates the childs of this entity.
        /// </summary>
        private void UpdateChildren(object source)
        {
            for (int i = 0; i < this.m_children.Count; i++)
            {
                this.m_children[i].UpdateWorldMatrix(ref this.m_worldMatrix, source);
            }
        }

        /// <summary>
        /// Updates the volume of this entity.
        /// </summary>
        protected virtual void UpdateWorldVolume()
        {
            BoundingBox oldWorldAABB = m_worldAABB;

            m_worldAABB = m_localAABB.Transform(this.m_worldMatrix);
            Matrix mat = Matrix.CreateTranslation(m_localVolume.Center);
            Matrix.Multiply(ref mat, ref m_worldMatrix, out mat); //mat = mat * this.WorldMatrix;
            
            m_worldVolume = new BoundingSphere(mat.Translation, m_localVolume.Radius);

            if (oldWorldAABB.Contains(m_worldAABB) != ContainmentType.Contains)
            {   //New world AABB is not same as previous world AABB
                InvalidateRenderObjects();
            }
        }

        protected void InvalidateRenderObjects(bool sortIntoCullobjects = false)
        {
            if (this.RenderObjects != null)
            {
                foreach (MyRenderObject renderObject in m_renderObjects)
                {
                    renderObject.SetDirty();
                    if (Visible)
                    {
                        MyRender.UpdateRenderObject(renderObject, sortIntoCullobjects);
                    }
                }
            }
        }


        /// <summary>
        /// Update volume hr and of all children.
        /// </summary>
        /// <param name="volume"></param>
        private void UpdateAABBHr(ref BoundingBox volume)
        {
            UpdateWorldVolume();

            BoundingBox box = MyMath.CreateInvalidAABB();
            BoundingBox.CreateMerged(ref box, ref this.m_worldAABB, out box);

            for (int i = 0; i < this.m_children.Count; i++)
            {
                this.m_children[i].UpdateAABBHr(ref box);
            }

            m_worldAABBHr = box;
            m_worldVolumeHr = BoundingSphere.CreateFromBoundingBox(m_worldAABBHr);

            BoundingBox.CreateMerged(ref box, ref volume, out volume);
        }

        public void UpdateAABBHr()
        {
            BoundingBox box = MyMath.CreateInvalidAABB();
            UpdateAABBHr(ref box);
        }

        #endregion

        #region Draw Methods

        /// <summary>
        /// Check if we have to draw this phys object in this frame.
        /// </summary>
        /// <returns>Returns true if visible from camera.</returns>
        public bool IsVisible()
        {
            if (!MyEntities.IsVisible(this))
            {
                return false;
            }

            if (!this.Visible)
            {
                return false;
            }

            if (!this.Activated)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Gets the lod0 model of the entity. Null if there is no model applicable.
        /// </summary>
        public virtual MyModel GetModelLod0()
        {
            return ModelLod0;
        }

        /// <summary>
        /// Gets the lod1 model of the entity. Null if there is no model applicable.
        /// </summary>
        public virtual MyModel GetModelLod1()
        {
            return ModelLod1;
        }

        /// <summary>
        /// Draws this object's model and return true. If object isn't in frustum or for whatever reason we won't draw it, return false.
        /// </summary>
        /// <returns></returns>
        public virtual bool Draw(MyRenderObject renderObject = null)
        {
            if (IsVisible())
            {
                MyRender.AddRenderObjectToDraw(renderObject ?? RenderObjects[0]);
                return true;
            }

            return false;
        }

        public void PreloadTextures()
        {
            if (ModelLod0 != null)
                ModelLod0.PreloadTextures(LoadingMode.Immediate, MaterialIndex);
            if (ModelLod1 != null)
                ModelLod1.PreloadTextures(LoadingMode.Immediate, MaterialIndex);
            if (ModelLod2 != null)
                ModelLod2.PreloadTextures(LoadingMode.Immediate, MaterialIndex);
        }

        public virtual void PreloadForDraw()
        {
            PreloadTextures();
            
            if (ModelLod0 != null)
            {
                ModelLod0.LoadInDraw();
            }

            if (ModelLod1 != null)
            {
                ModelLod1.LoadInDraw();
            }

            if (ModelLod2 != null)
            {
                ModelLod2.LoadInDraw();
            }
        }

        /// <summary>
        /// Draw debug.  
        /// </summary>
        /// <returns></returns>
        public virtual bool DebugDraw()
        {
            if (MyMwcFinalBuildConstants.DrawHelperPrimitives)
            {
                DebugDrawVolume();
                DebugDrawOBB();
                MyDebugDraw.DrawAxis(WorldMatrix, LocalVolume.Radius, 1);
/*
                if (Vector3.Distance(GetPosition(), MyCamera.Position) < 200)
                {
                    Vector4 clr = Vector4.One;
                    if (this is MyDummyPoint && (((this as MyDummyPoint).DummyFlags) & MyDummyPointFlags.PARTICLE) > 0)
                        MyDebugDraw.DrawAABBLine(ref m_worldAABB, ref clr, 1);
                }*/
            }

            if (MyMwcFinalBuildConstants.DrawJLXCollisionPrimitives)
            {
                DebugDrawPhysics();
            }

            if (MyMwcFinalBuildConstants.DrawNormalVectors)
            {
                DebugDrawNormalVectors();
            }

            return true;
        }

        /// <summary>
        /// Draws world bounding box of this entity
        /// </summary>
        [Conditional("DEBUG"), Conditional("DEVELOP")]
        public void DebugDrawWorldAABB()
        {
            BoundingBox aabb = WorldAABB;
            Vector4 color = Vector4.One;
            MyDebugDraw.DrawAABB(ref aabb, ref color, 1.0f);
        }

        /// <summary>
        /// Debug draw volume of this entity.
        /// </summary>
        [Conditional("DEBUG"), Conditional("DEVELOP")]
        public void DebugDrawVolume()
        {
            if ((this is MyVoxelMap) == false)
            {
                MyDebugDraw.DrawSphereWireframe(Matrix.CreateScale(m_worldVolume.Radius) * Matrix.CreateTranslation(m_worldVolume.Center), Color.Red.ToVector3(), 1);
            }
        }

        /// <summary>
        /// Debug draw hierarchical volume of this entity.
        /// </summary>
        [Conditional("DEBUG"), Conditional("DEVELOP")]
        public void DebugDrawVolumeHr()
        {
            if ((this is MyVoxelMap) == false)
            {
                MyDebugDraw.DrawSphereWireframe(Matrix.CreateScale(m_worldVolumeHr.Radius) * Matrix.CreateTranslation(m_worldVolumeHr.Center), Color.Red.ToVector3(), 1);
            }
        }

        /// <summary>
        /// Debug draw box of this entity.
        /// </summary>
        [Conditional("DEBUG"), Conditional("DEVELOP")]
        public virtual void DebugDrawOBB()
        {
            Vector3 boundingBoxSize = LocalAABB.Size();

            const float alpha = 1.0f;
            MyDebugDraw.DrawHiresBoxWireframe(Matrix.CreateScale(boundingBoxSize) * Matrix.CreateTranslation(this.LocalVolumeOffset) * this.m_worldMatrix, Color.DarkRed.ToVector3(), alpha);
        }

        /// <summary>
        /// Debug draw box of this entity.
        /// </summary>
        [Conditional("DEBUG"), Conditional("DEVELOP")]
        public virtual void DebugDrawAABB()
        {
            const float alpha = 1.0f;
            MyDebugDraw.DrawHiresBoxWireframe(Matrix.CreateScale(WorldAABB.Size()) * Matrix.CreateTranslation(WorldAABB.GetCenter()), Color.Gray.ToVector3(), alpha);
        }

        /// <summary>
        /// Debug draw box of this entity.
        /// </summary>
        [Conditional("DEBUG"), Conditional("DEVELOP")]
        public virtual void DebugDrawAABBHr()
        {
            const float alpha = 1.0f;
            MyDebugDraw.DrawHiresBoxWireframe(Matrix.CreateScale(m_worldAABBHr.Size()) * Matrix.CreateTranslation(m_worldAABBHr.GetCenter()), Color.Gray.ToVector3(), alpha);
        }

        /// <summary>
        /// Debug draw box of this entity.
        /// </summary>
        [Conditional("DEBUG"), Conditional("DEVELOP"), Conditional("RELEASE")]
        public virtual void DebugDrawBox(Vector4 color, bool bWireFrame)
        {
            /*
            BoundingBox worldBB = GetLocalAABB();
            Vector3 size = worldBB.Max - worldBB.Min;
            Vector3 center = size / 2f;
            center = center + worldBB.Min;
            //Matrix mat = Matrix.CreateWorld(center, this.worldMatrix.Forward, this.worldMatrix.Up);

            Matrix tmpInv = Matrix.Identity;
            tmpInv.Translation = -center;
            BoundingBox localbox = worldBB.Transform(tmpInv);    //to local


            Matrix mat = Matrix.CreateTranslation(LocalVolumeOffset) * this.WorldMatrix;
            MySimpleObjectDraw.DrawTransparentBox(ref mat, ref localbox, ref color, bWireFrame, 1);

            */

            Matrix mat = Matrix.Identity;
            BoundingBox box = WorldAABB;
            MySimpleObjectDraw.DrawTransparentBox(ref mat, ref box, ref color, bWireFrame, 1);
        }


        /// <summary>
        /// If model of this phys object uses alpha for rendering, this method will calculate that alpha
        /// Of course childs of this class must implement it's own alpha calculation, because this one will throw an exception.
        /// Children shouldn't call this base method
        /// Only for drawing this object, because some objects need to use special world matrix
        /// </summary>
        /// <returns></returns>
        [Conditional("DEBUG"), Conditional("DEVELOP")]
        public virtual void DebugDrawNormalVectors()
        {
            bool retVal = IsVisible();

            if (retVal == false)
                return;

            // Must be enabled
            if (!MyMwcFinalBuildConstants.ENABLE_VERTEX_NORMALS_DEBUG_DRAW)
                return;


            if ((this == MySession.PlayerShip) &&
                (MyGuiScreenGamePlay.Static.CameraAttachedTo == MyCameraAttachedToEnum.PlayerMinerShip)) return;

            const float MAX_DRAW_DISTANCE = 300;
            if (GetDistanceBetweenCameraAndBoundingSphere() > MAX_DRAW_DISTANCE) return;

            //Matrix worldMatrixNotCentered = Matrix.CreateTranslation(-m_invertedCenterOfMass) * WorldMatrix;
            Matrix worldMatrixNotCentered = WorldMatrix;
            Matrix transformMatrix = worldMatrixNotCentered;

            MyDebugDrawCachedLines.Clear();

            //  This is just a reserve
            const int NUMBER_OF_ADD_TRIANGLES_IN_LOOP = 1;

            int vertexIndex = 0;
            while (true)
            {
                //bool finished = triangleIndex >= mesh.GetNumTriangles();
                bool finished = vertexIndex >= m_modelLod0.GetVerticesCount();

                if ((MyDebugDrawCachedLines.IsFull(-NUMBER_OF_ADD_TRIANGLES_IN_LOOP)) || (finished))
                {
                    MyDebugDrawCachedLines.DrawLines();
                    MyDebugDrawCachedLines.Clear();
                }

                if (finished)
                {
                    break;
                }

                //  We now transform the triangleVertexes into world space (we could keep leave the mesh alone
                //  but at this point 3 vector transforms is probably not a major slow down)
                Vector3 vertex0 = m_modelLod0.GetVertex(vertexIndex);
                Vector3 normal = m_modelLod0.GetVertexNormal(vertexIndex);
                Vector3 vertex1 = vertex0 + normal * 1;

                Vector3.Transform(ref vertex0, ref transformMatrix, out vertex0);
                Vector3.Transform(ref vertex1, ref transformMatrix, out vertex1);

                MyDebugDrawCachedLines.AddLine(vertex0, vertex1, Color.Red, Color.Red);

                vertexIndex++;
            }
        }



        /// <summary>
        /// Draw physical representation of entity
        /// </summary>
        [Conditional("DEBUG"), Conditional("DEVELOP")]
        public void DebugDrawPhysics()
        {
            if (this.Physics == null)
            {
                return;
            }

            const float maxDrawDistance = 50;

            if (GetDistanceBetweenCameraAndBoundingSphere() > maxDrawDistance)
            {
                return;
            }

            this.Physics.DebugDraw();

            MyDebugDraw.DrawLine3D(GetPosition(), GetPosition() + Physics.LinearVelocity * 4, Color.Red, Color.Red);
        }

        public virtual void DebugDrawDeactivated()         
        {
            if (Activated || !Visible)
            {
                return;
            }

            var model = GetModelLod1();
            if (model == null) 
            {
                model = GetModelLod0();                
            }
            if (model == null) 
            {
                return;
            }

            Matrix transformMatrix = WorldMatrix;

            MyDebugDrawCachedLines.Clear();

            //  This is just a reserve
            const int numberOfAddTrianglesInLoop = 3;

            int triangleIndex = 0;
            while (true)
            {
                //bool finished = triangleIndex >= mesh.GetNumTriangles();
                bool finished = triangleIndex >= model.GetTrianglesCount();

                if ((MyDebugDrawCachedLines.IsFull(-numberOfAddTrianglesInLoop)) || (finished))
                {
                    MyDebugDrawCachedLines.DrawLines();
                    MyDebugDrawCachedLines.Clear();
                }

                if (finished)
                {
                    break;
                }

                MyTriangleVertexIndices triangle = model.Triangles[triangleIndex];

                //  We now transform the triangleVertexes into world space (we could keep leave the mesh alone
                //  but at this point 3 vector transforms is probably not a major slow down)
                Vector3 triVec0 = model.GetVertex(triangle.I0);
                Vector3 triVec1 = model.GetVertex(triangle.I2);
                Vector3 triVec2 = model.GetVertex(triangle.I1);

                // Move triangle into world space                        
                Vector3.Transform(ref triVec0, ref transformMatrix, out triVec0);
                Vector3.Transform(ref triVec1, ref transformMatrix, out triVec1);
                Vector3.Transform(ref triVec2, ref transformMatrix, out triVec2);

                MyDebugDrawCachedLines.AddLine(triVec0, triVec1, Color.Green, Color.Green);
                MyDebugDrawCachedLines.AddLine(triVec1, triVec2, Color.Green, Color.Green);
                MyDebugDrawCachedLines.AddLine(triVec2, triVec0, Color.Green, Color.Green);

                //MyDebugDraw.AddDrawTriangle(triVec0, triVec1, triVec2, new Color(0,0.8f, 0, 0.1f));

                triangleIndex++;
            }
        }

        public virtual void InitDrawTechniques()
        {
        }

        protected void InitDrawTechniques(MyMeshDrawTechnique drawTechnique)
        {
            InitDrawTechnique(ModelLod0, drawTechnique);
            InitDrawTechnique(ModelLod1, drawTechnique);
            InitDrawTechnique(ModelLod2, drawTechnique);
        }

        private void InitDrawTechnique(MyModel model, MyMeshDrawTechnique drawTechnique)
        {
            if (model != null)
            {
                //Be careful about this, return correct technique in entity::GetMaterial
                model.SetDrawTechnique(drawTechnique);
                foreach (MyMesh mesh in model.GetMeshList())
                {
                    foreach (MyMeshMaterial material in mesh.Materials)
                    {
                        material.DrawTechnique = drawTechnique;
                    }
                }
            }
        }

        #endregion

        #region Intersection Methods

        //  Calculates intersection of line with object.
        public virtual bool GetIntersectionWithLine(ref MyLine line, out Vector3? v, bool useCollisionModel = true, IntersectionFlags flags = IntersectionFlags.ALL_TRIANGLES)
        {
            v = null;
            MyModel collisionModel = ModelLod0;
            if (useCollisionModel)
                collisionModel = ModelCollision;

            if (collisionModel != null)
            {
                MyIntersectionResultLineTriangleEx? result = collisionModel.GetTrianglePruningStructure().GetIntersectionWithLine(this, ref line, flags);
                if (result != null)
                {
                    v = result.Value.IntersectionPointInWorldSpace;
                    return true;
                }
            }
            else
                Debug.Assert(false);//this should be overriden by child class if object has no model by default
            return false;
        }

        //  Calculates intersection of line with any triangleVertexes in this model instance. Closest intersection and intersected triangleVertexes will be returned.
        public virtual bool GetIntersectionWithLine(ref MyLine line, out MyIntersectionResultLineTriangleEx? t, IntersectionFlags flags = IntersectionFlags.ALL_TRIANGLES)
        {
            //Cannot profile because of multithreading
            //MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().StartProfilingBlock("MyEntity.LineIntersection fast");

            bool ret = false;

            t = null;
            MyModel collisionModel = ModelLod0;

            if (collisionModel != null)
            {
                MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().StartProfilingBlock("MyEntity.GetIntersectionWithLine on model");
                MyIntersectionResultLineTriangleEx? result = collisionModel.GetTrianglePruningStructure().GetIntersectionWithLine(this, ref line, flags);
                MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().EndProfilingBlock();
                if (result != null)
                {
                    t = result.Value;
                    ret = true;
                }
            }

            //Cannot profile because of multithreading
            //MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().EndProfilingBlock();
            return ret;

        }

        //  Calculates intersection of line with any bounding sphere in this model instance. Center of the bounding sphere will be returned.
        //  It takes boundingSphereRadiusMultiplier argument which serves for extending the influence (radius) for interaction with line.
        public virtual Vector3? GetIntersectionWithLineAndBoundingSphere(ref MyLine line, float boundingSphereRadiusMultiplier)
        {
            if (m_modelLod0 == null)
                return null;

            BoundingSphere vol = m_worldVolume;
            vol.Radius *= boundingSphereRadiusMultiplier;

            //  Check if line intersects phys object's current bounding sphere, and if not, return 'no intersection'
            if (!MyUtils.IsLineIntersectingBoundingSphere(ref line, ref vol))
                return null;

            return vol.Center;
        }

        //  Return true if object intersects specified sphere.
        //  This method doesn't return exact point of intersection or any additional data.
        //  We don't look for closest intersection - so we stop on first intersection found.
        public virtual bool GetIntersectionWithSphere(ref BoundingSphere sphere)
        {
            MyModel collisionModel = ModelLod0;

            if (collisionModel != null)
                return collisionModel.GetTrianglePruningStructure().GetIntersectionWithSphere(this, ref sphere);
            return false;
        }

        //  Return list of triangles intersecting specified sphere. 
        public void GetTrianglesIntersectingSphere(ref BoundingSphere sphere, Vector3? referenceNormalVector, float? maxAngle,
                                                   List<MyTriangle_Vertex_Normals> retTriangles, int maxNeighbourTriangles)
        {
            MyModel collisionModel = ModelLod0;

            if (collisionModel != null)
            {
                collisionModel.GetTrianglePruningStructure().GetTrianglesIntersectingSphere(ref sphere, referenceNormalVector, maxAngle, retTriangles, maxNeighbourTriangles);
            }
        }

        private Vector3[] m_frustumIntersectionCorners = new Vector3[8];

        //  Return true if bounding sphere of this object intersects bounding frustum
        public virtual bool GetIntersectionWithBoundingFrustum(ref BoundingFrustum boundingFrustum)
        {
            ContainmentType con = boundingFrustum.Contains(WorldAABB);
            if (con == ContainmentType.Contains)
            {
                return true;
            }

            if (con == ContainmentType.Intersects)
            {
                if (ModelLod0 == null)
                {
                    return true;
                }

                for (int v = 0; v < ModelLod0.GetVerticesCount(); v++)
                {
                    Vector3 vet = ModelLod0.GetVertex(v);
                    Vector3 transformed = Vector3.Transform(vet, WorldMatrix);
                    ContainmentType con2 = boundingFrustum.Contains(transformed);
                    if (con2 != ContainmentType.Disjoint)
                    {
                        return true;
                    }
                }

                boundingFrustum.GetCorners(m_frustumIntersectionCorners);
                MyLine l0 = new MyLine(m_frustumIntersectionCorners[0], m_frustumIntersectionCorners[4], true);
                MyLine l1 = new MyLine(m_frustumIntersectionCorners[1], m_frustumIntersectionCorners[5], true);
                MyLine l2 = new MyLine(m_frustumIntersectionCorners[2], m_frustumIntersectionCorners[6], true);
                MyLine l3 = new MyLine(m_frustumIntersectionCorners[3], m_frustumIntersectionCorners[7], true);

                var prun = ModelLod0.GetTrianglePruningStructure();

                if (prun.GetIntersectionWithLine(this, ref l0).HasValue || prun.GetIntersectionWithLine(this, ref l1).HasValue
                    || prun.GetIntersectionWithLine(this, ref l2).HasValue || prun.GetIntersectionWithLine(this, ref l3).HasValue)
                {
                    return true;
                }
            }

            return false;
        }

        //  Smalles distance between camera and bounding sphere of this phys object. Result is always positive, even if camera is inside the sphere.
        public float GetSmallestDistanceBetweenCameraAndBoundingSphere()
        {
            Vector3 campos = MyCamera.Position;
            return MyUtils.GetSmallestDistanceToSphereAlwaysPositive(ref campos, ref m_worldVolume);
        }

        //  Largest distance from camera to bounding sphere of this phys object. Result is always positive, even if camera is inside the sphere.
        //  It's actualy distance between camera and opposite side of the sphere
        public float GetLargestDistanceBetweenCameraAndBoundingSphere()
        {
            Vector3 campos = MyCamera.Position;
            return MyUtils.GetLargestDistanceToSphere(ref campos, ref m_worldVolume);
        }

        //  Distance from camera to bounding sphere of this phys object. Result is always positive, even if camera is inside the sphere.
        public float GetDistanceBetweenCameraAndBoundingSphere()
        {
            Vector3 campos = MyCamera.Position;
            return MyUtils.GetSmallestDistanceToSphereAlwaysPositive(ref campos, ref m_worldVolume);
        }

        //  Distance from camera to position of entity.
        public float GetDistanceBetweenCameraAndPosition()
        {
            return Vector3.Distance(MyCamera.Position, this.GetPosition());
        }

        // When ie. Large Weapon is hit, all parts must be ignored in aoe damage
        public virtual MyEntity GetBaseEntity()
        {
            return this;
        }
        #endregion

        #region Children Methods

        /// <summary>
        /// Adds the child.
        /// </summary>
        /// <param name="child">The child.</param>
        /// <param name="preserveWorldPos">if set to <c>true</c> [preserve absolute position].</param>
        public void AddChild(MyEntity child, bool preserveWorldPos = false)
        {
            //MyEntities.Remove(child);  // if it's already in the world, remove it
            if (preserveWorldPos)
            {
                var tmpWorldMatrix = child.WorldMatrix;

                this.Children.Add(child);

                child.WorldMatrix = tmpWorldMatrix;
            }
            else
            {
                this.Children.Add(child);
            }
        }

        /// <summary>
        /// Adds the child.
        /// </summary>
        /// <param name="child">The child.</param>
        /// <param name="preserveWorldPos">if set to <c>true</c> [preserve absolute position].</param>
        public void RemoveChild(MyEntity child, bool preserveWorldPos = false)
        {
            if (preserveWorldPos)
            {
                var tmpWorldMatrix = child.WorldMatrix;

                this.Children.Remove(child);

                child.WorldMatrix = tmpWorldMatrix;
            }
            else
            {
                this.Children.Remove(child);
            }
        }

        /// <summary>
        /// Finds the child.
        /// </summary>
        /// <param name="childName">Name of the child.</param>
        /// <returns></returns>
        public MyEntity FindChild(string childName)
        {
            return this.Children.FirstOrDefault(entity => string.Compare(childName, entity.Name, true) == 0);
        }

        /// <summary>
        /// Finds the child.
        /// </summary>
        /// <param name="childIndex">Index of the child.</param>
        /// <returns></returns>
        public MyEntity FindChild(int childIndex)
        {
            var list = this.Children as IList<MyEntity>;

            return list != null ? list[childIndex] : this.Children.ElementAt(childIndex);
        }

        /// <summary>
        /// Enumerate the children.
        /// Do not use this method in performance critical code. Makes garbadge !
        /// </summary>
        /// <param name="enumerationFlags">The enumeration flags.</param>
        /// <returns></returns>
        public IEnumerable<MyEntity> EnumChildren(EnumerationFlags enumerationFlags = EnumerationFlags.None)
        {
            for (int i = 0; i < this.m_children.Count; i++)
            {
                var child = this.m_children[i];

                yield return child;

                if ((enumerationFlags & EnumerationFlags.Hierarchically) != 0)
                {
                    foreach (var subChild in child.EnumChildren(enumerationFlags))
                    {
                        yield return subChild;
                    }
                }
            }
        }

        #endregion

        #region Entity events

        /// <summary>
        /// Notifies sub dependent resources about entity change.
        /// </summary>
        /// <param name="source">Source of change-or-null if unknown.</param>
        private void NotifyEntityChange(object source)
        {
            //Like to be Obsolete

            IMyNotifyEntityChanged notifier;

            {
                notifier = this.Physics;

                if (notifier != null && notifier != source)
                {
                    notifier.OnWorldPositionChanged(source);
                }
            }

            {
                notifier = this;

                if (notifier != source)
                {
                    notifier.OnWorldPositionChanged(source);
                }
            }
        }

        /// <summary>
        /// Called on some contact start with this entity.
        /// </summary>
        /// <param name="contactInfo">The contact info.</param>
        protected virtual void OnContactStart(MyContactEventInfo contactInfo)
        {
            MyRender.GetRenderProfiler().StartProfilingBlock("MyEntity::OnContactStart");

            if (this.Physics.PlayCollisionCueEnabled)
            {
                MyAudio.PlayCollisionCue(contactInfo, MyMaterialsConstants.MyMaterialCollisionType.Start);
            }

            if (MyMwcFinalBuildConstants.DrawCollisionSpotsInHud)
            {
                MyHud.DebugClearAndAddText(contactInfo.m_ContactPoint, new StringBuilder("COLLISION POINT"));
            } 

            MyRender.GetRenderProfiler().EndProfilingBlock();
        }

        /// <summary>
        /// Called on some contact end with this entity.
        /// </summary>
        /// <param name="contactInfo">The contact info.</param>
        protected virtual void OnContactEnd(MyContactEventInfo contactInfo)
        {
            if (this.Physics.PlayCollisionCueEnabled)
            {
                MyAudio.PlayCollisionCue(contactInfo, MyMaterialsConstants.MyMaterialCollisionType.End);
            }
        }

        /// <summary>
        /// Called when [contact touches] with this entity.
        /// </summary>
        /// <param name="contactInfo">The contact info.</param>
        protected virtual void OnContactTouch(MyContactEventInfo contactInfo)
        {
            if (this.Physics.PlayCollisionCueEnabled)
            {
                MyAudio.PlayCollisionCue(contactInfo, MyMaterialsConstants.MyMaterialCollisionType.Touch);
            }
        }

        /// <summary>
        /// Called when [contact] with entity.
        /// </summary>
        /// <param name="constraint">The constraint.</param>
        /// <returns></returns>
        protected virtual bool OnContact(ref MyRBSolverConstraint constraint)
        {
            if (OnContactEvent != null)
            {
                OnContactEvent(constraint.GetOtherEntity(this));
            }

            return true;
        }

        /// <summary>
        /// Called when [deserialized].
        /// </summary>
        protected virtual void OnDeserialized()
        {
        }

        /// <summary>
        /// Called when [activated] which for entity means that was added to scene.
        /// </summary>
        /// <param name="source">The source of activation.</param>
        protected override void OnActivated(object source)
        {
            System.Diagnostics.Debug.Assert(m_activated == false, "Object was insertes twice into the scene");

            if (!Activated)
                return;

            MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().StartProfilingBlock("OnActivated");

            m_activated = true;

            base.OnActivated(source);

            if (Visible)
            {
                MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().StartProfilingBlock("UpdateRenderobject");
                UpdateRenderObject(true);                
                MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().EndProfilingBlock();
            }

            if (this.Physics != null && !this.Physics.Enabled)
            {
                MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().StartProfilingBlock("Physics.Enabled");
                this.Physics.Enabled = true;
                MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().EndProfilingBlock();
            }

            MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().StartProfilingBlock("Enabled");
            //TODO: Must be set another way
            //Enabled = true;
            MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().EndProfilingBlock();

            UpdateHudMarker();

            //Visible = true;

            MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().StartProfilingBlock("AddToGamePruningStructure");
            AddToGamePruningStructure();
            MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().EndProfilingBlock();

            MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().EndProfilingBlock();
        }

        /// <summary>
        /// Called when [deactivated] which for entity means that was removed from scene.
        /// </summary>
        /// <param name="source">The source of deactivation.</param>
        protected override void OnDeactivated(object source)
        {
            //System.Diagnostics.Debug.Assert(m_activated == true);
            m_activated = false;            

            if (this.Physics != null && this.Physics.Enabled)
            {
                this.Physics.Enabled = false;
            }

            MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().StartProfilingBlock("Enabled");
            //TODO: Must be set another way
            //Enabled = false;
            MinerWars.AppCode.Game.Render.MyRender.GetRenderProfiler().EndProfilingBlock();

            MyHud.RemoveText(this);

            UpdateRenderObject(false);

            //Visible = false;

            RemoveFromGamePruningStructure();

            base.OnDeactivated(source);
        }

        public override void NotifyActivated(object source)
        {
            if (Activated)
            {
                base.NotifyActivated(source);
            }
            else 
            {
                NotifyDeactivated(source);
            }
        }

        public override void NotifyDeactivated(object source)
        {
            base.NotifyDeactivated(source);
        }

        public event EventHandler OnPositionChanged;

        /// <summary>
        /// This event may not be invoked at all, when calling MyEntities.CloseAll, marking is bypassed
        /// </summary>
        public event Action<MyEntity> OnMarkForClose;
        public event Action<MyEntity> OnClose;
        public event Action<MyEntity> OnClosing;
        public event Action<MyEntity> OnContactEvent;

        /// <summary>
        /// Arguments: Killed entity, Killer
        /// </summary>
        public event DieHandler OnDie;

        #endregion

        #region Notification Methods

        /// <summary>
        /// Rise the OnContactStart event.
        /// </summary>
        /// <param name="contactInfo">The contact info.</param>
        internal void NotifyContactStart(MyContactEventInfo contactInfo)
        {
            OnContactStart(contactInfo);
        }

        /// <summary>
        /// Rise the OnContactsEnd event.
        /// </summary>
        /// <param name="contactInfo">The contact info.</param>
        internal void NotifyContactEnd(MyContactEventInfo contactInfo)
        {
            OnContactEnd(contactInfo);
        }

        /// <summary>
        /// Rise the OnContactTouche event.
        /// </summary>
        /// <param name="contactInfo">The contact info.</param>
        internal void NotifyContactTouch(MyContactEventInfo contactInfo)
        {
            OnContactTouch(contactInfo);
        }

        /// <summary>
        /// Rise the OnContact event.
        /// </summary>
        /// <param name="constraint">The constraint.</param>
        /// <returns></returns>
        internal bool NotifyContact(ref MyRBSolverConstraint constraint)
        {
            return OnContact(ref constraint);
        }

        /// <summary>
        /// Notifies entity that the chidren collection has changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
        private void NotifyChidrenCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    foreach (var changedItem in e.NewItems.Cast<MyEntity>())
                    {
                        changedItem.Parent = this;
                        if (m_activated && !changedItem.m_activated)
                            changedItem.NotifyActivated(sender);
                        changedItem.UpdateWorldMatrix(ref this.m_worldMatrix);
                    }
                    break;
                case NotifyCollectionChangedAction.Remove:
                    {
                        // TODO: Simplify
                        if (e.OldItems == this.Children)
                        {
                            for (int i = 0; i < this.m_children.Count; i++)
                            {
                                this.m_children[i].Parent = null;
                                this.m_children[i].UpdateWorldMatrix();

                                if (m_activated)
                                    this.m_children[i].NotifyDeactivated(sender);
                            }
                        }
                        else
                        {
                            foreach (var changedItem in e.OldItems)
                            {
                                var changedEntity = (MyEntity)changedItem;

                                changedEntity.Parent = null;
                                //changedEntity.UpdateWorldMatrix();

                                if (m_activated)
                                    changedEntity.NotifyDeactivated(sender);
                            }
                        }

                        break;
                    }
            }
        }

        /// <summary>
        /// Notifies that entity was added to scene (activated)
        /// </summary>
        /// <param name="source"></param>
        internal void NotifyAddedToScene(object source)
        {
            if (Activated)
            {
                NotifyActivated(source);
            }
            else
            {
                NotifyDeactivated(source);
            }
        }

        /// <summary>
        /// Notifies that entity was removed from scene (deactivated)
        /// </summary>
        /// <param name="source"></param>
        internal void NotifyRemovedFromScene(object source)
        {
            NotifyDeactivated(source);
        }

        #endregion

        #region Gameplay methods & properties

        public bool IsExploded()
        {
            return m_isExploded;
        }

        public virtual void RepairToMax()
        {
            //Health = MaxHealth;
            HealthRatio = MyGameplayConstants.HEALTH_RATIO_MAX;
        }

        public virtual float Health
        {
            get 
            {
                return MaxHealth * HealthRatio;
            }
            set 
            {
                if (MaxHealth != 0f)
                {
                    HealthRatio = value / MaxHealth;
                }
                else
                {
                    HealthRatio = 0f;
                }
            }
        }

        public float MaxHealth
        {            
            get 
            {
                if (m_maxHealth != null)
                {
                    return m_maxHealth.Value;
                }
                else 
                {                    
                    return m_gameplayProperties.MaxHealth;                     
                }
            }
            set 
            {
                Debug.Assert(value > 0f);
                Debug.Assert(!float.IsNaN(value));
                Debug.Assert(!float.IsInfinity(value));
                if (m_gameplayProperties.MaxHealth == value)
                {
                    m_maxHealth = null;
                }
                else
                {
                    m_maxHealth = value;
                }
            }
        }

        /// <summary>
        /// Get max health field, use only when you want to save this value to objectbuilder
        /// </summary>
        /// <returns></returns>
        public float? GetMaxHealth() 
        {
            return m_maxHealth;
        }
        /// <summary>
        /// Set max health field, use only when you want to load this value from objectbuilder
        /// </summary>
        /// <param name="maxHealth"></param>
        protected void SetMaxHealth(float? maxHealth) 
        {
            if (maxHealth != null) 
            {
                Debug.Assert(maxHealth.Value > 0f);
                Debug.Assert(!float.IsInfinity(maxHealth.Value));
                Debug.Assert(!float.IsNaN(maxHealth.Value));
            }
            m_maxHealth = maxHealth;
        }

        public float HealthRatio 
        {
            get 
            {
                Debug.Assert(m_healthRatio >= MyGameplayConstants.HEALTH_RATIO_DEATH);
                Debug.Assert(m_healthRatio <= MyGameplayConstants.HEALTH_RATIO_MAX);
                m_healthRatio = MathHelper.Clamp(m_healthRatio, MyGameplayConstants.HEALTH_RATIO_DEATH, MyGameplayConstants.HEALTH_RATIO_MAX);
                return m_healthRatio;
            }
            set 
            {
                //Debug.Assert(value >= MyGameplayConstants.HEALTH_RATIO_DEATH);
                //Debug.Assert(value <= MyGameplayConstants.HEALTH_RATIO_MAX);
                m_healthRatio = MathHelper.Clamp(value, MyGameplayConstants.HEALTH_RATIO_DEATH, MyGameplayConstants.HEALTH_RATIO_MAX);                
            }
        }
        
        public bool IsDestructible
        {
            get 
            { 
                return (PersistentFlags & MyPersistentEntityFlags.Destructible) != 0; 
            }
            set 
            {
                if (value)
                {
                    PersistentFlags |= MyPersistentEntityFlags.Destructible;
                }
                else
                {
                    PersistentFlags &= (~MyPersistentEntityFlags.Destructible);
                }
            }
        }


        protected virtual void DoDamageInternal(float playerDamage, float damage, float empDamage, MyDamageType damageType, MyAmmoType ammoType, MyEntity damageSource, bool justDeactivate)
        {
            if (damageSource == MySession.PlayerShip && (damageSource != this && MinerWars.AppCode.Game.World.Global.MyFactions.GetFactionsRelation(damageSource, this) == MinerWars.AppCode.Game.World.Global.MyFactionRelationEnum.Enemy))
            {
                playerDamage *= MyGameplayConstants.GameplayDifficultyProfile.DamageFromPlayerToEnemyMultiplicator;
                damage *= MyGameplayConstants.GameplayDifficultyProfile.DamageFromPlayerToEnemyMultiplicator;
                empDamage *= MyGameplayConstants.GameplayDifficultyProfile.DamageFromPlayerToEnemyMultiplicator;
            }

            Health = MathHelper.Clamp(Health - damage, 0, MaxHealth);

            TestDeath(damageSource);

        }

        ///<summary>
        ///Does domage to entity
        ///</summary>
        ///<param name="deltaHealth">Amount of damage</param>
        public void DoDamage(float playerDamage, float damage, float empDamage, MyDamageType damageType, MyAmmoType ammoType, MyEntity damageSource, bool justDeactivate = false)
        {
            Debug.Assert(!Closed, "Cannot do damage, entity is closed");

#if GPU_PROFILING
            if (this == MySession.PlayerShip)
                return; //We dont want die anymore while profiling!
#endif
            if (!IsDestructible || IsDummy) // Dummy entities are driven by host
            {
                return;
            }

            DoDamageInternal(playerDamage, damage, empDamage, damageType, ammoType, damageSource, justDeactivate);

            if (MyMultiplayerGameplay.IsRunning)
            {
                MyMultiplayerGameplay.Static.DoDamage(this, playerDamage, damage, empDamage, damageType, ammoType, damageSource, HealthRatio);
            }
        }

        private void TestDeath(MyEntity damageSource)
        {
            bool isDead = IsDead();
            if (!isDead && damageSource != null)
            {
                MyScriptWrapper.EntityAtacked(damageSource, this);
            }

            if (!m_wasDead && isDead)
            {
                MyScriptWrapper.OnEntityDeath(this, damageSource);
                RaiseOnDie(damageSource);
            }
            m_wasDead = isDead;
        }

        void RaiseOnDie(MyEntity killer)
        {
            var handler = OnDie;
            if (handler != null)
            {
                handler(this, killer);
            }
        }

        /// <summary>
        /// Decreases health of this entity to 0, if it is destructible.
        /// </summary>
        public virtual void Kill(MyEntity killer)
        {
            if (!IsDestructible)
            {
                if (this is MyStaticAsteroid)
                {
                    MyHudNotification.AddNotification(new MyHudNotification.MyNotification(Localization.MyTextsWrapperEnum.IndestructibleAsteroidNotification, 2000, null));
                }
                return;
            }

            Health = 0;

            TestDeath(killer);
        }

        /// <summary>
        /// Gets how much is entity damaged
        /// </summary>
        /// <returns></returns>
        public float GetDamageRatio()
        {
            return IsDestructible ? 1f - (HealthRatio) : 0.0f;
        }

        /// <summary>
        /// Indicates if prefab is damaged
        /// </summary>
        public bool IsDamaged()
        {
            return IsDestructible ? HealthRatio < MyGameplayConstants.HEALTH_RATIO_MAX : false;
        }

        /// <summary>
        /// Adds health to entity
        /// </summary>
        /// <param name="deltaHealth"></param>
        public virtual void AddHealth(float deltaHealth)
        {
            Health = Health + deltaHealth;
        }

        /// <summary>
        /// Indicates if entity is dead
        /// </summary>
        public virtual bool IsDead()
        {
            return IsDestructible ? HealthRatio <= MyGameplayConstants.HEALTH_RATIO_DEATH : false;
        }

        /// <summary>
        /// Sets entity name
        /// </summary>
        /// <param name="name">Name</param>
        public void SetName(string name)
        {
            Name = name;
            MyEntities.SetEntityName(this);
        }

        public virtual Vector3 GetHUDMarkerPosition()
        {
            return WorldVolume.Center;
        }

        public virtual float GetHUDDamageRatio() 
        {
            return GetDamageRatio();
        }

        public void GetChildrenRecursive(HashSet<MyEntity> result)
        {
            for (int i = 0; i < Children.Count; i++)
            {
                var entity = Children[i];
                result.Add(entity);
                entity.GetChildrenRecursive(result);
            }
        }

        public virtual Vector3 GetFormationPosition(MySmallShipBot bot)
        {
            Vector3 centerToBot = bot.GetPosition() - WorldVolume.Center;
            Vector3 centerToBotNormalized = Vector3.Normalize(centerToBot);
            
            return WorldVolume.Center + centerToBotNormalized * (WorldVolume.Radius + MyAIConstants.FORMATION_SPACING);
        }
        #endregion

        #region Implementation of IMyNotifyEntityChanged

        // Because for now entity = script resource entity also implements this interface for inheritors.

        /// <summary>
        /// Called when [world position changed].
        /// </summary>
        /// <param name="source">The source object that caused this event.</param>
        public virtual void OnWorldPositionChanged(object source)
        {
            Debug.Assert(source != this, "Recursion detected!");

            UpdateWorldVolume();

            UpdateGamePruningStructure();

            if (OnPositionChanged != null)
            {
                OnPositionChanged(this, EventArgs.Empty);
            }
        }

        #endregion

        #region Implementation of INotifyMemberChanged

        /// <summary>
        /// Called when [member changed].
        /// </summary>
        /// <param name="memberInfo">The member info.</param>
        public void OnMemberChanged(MemberInfo memberInfo)
        {
            {
                UpdateWorldMatrix(null);
            }
        }

        #endregion

        #region Drawing, objectbuilder, init & close

        protected void Init(StringBuilder displayName, MyMwcObjectBuilder_Base objectBuilder)
        {
            Closed = false;
            m_wasDead = false;
            m_isExploded = false;

            // System.Diagnostics.Debug.Assert(objectBuilder != null);

            if (objectBuilder != null)
            {
                this.EntityId = MyEntityIdentifier.FromNullableInt(objectBuilder.EntityId);
                this.m_objectBuilder = objectBuilder.Clone(); // MyMwcUtils.DeepCopy(objectBuilder);
                m_gameplayProperties = MyGameplayConstants.GetGameplayProperties(objectBuilder, Faction);

                Debug.Assert(m_gameplayProperties != null);
                if (m_gameplayProperties != null)
                {
                    MaxHealth = m_gameplayProperties.MaxHealth;
                    Health = m_gameplayProperties.MaxHealth;
                }

                PersistentFlags = objectBuilder.PersistentFlags;

                this.Name = objectBuilder.Name;
                MyEntities.SetEntityName(this, false);

                IsGenerated = objectBuilder.Generated;

                if (IsGenerated)
                {
                    Flags &= ~EntityFlags.NeedsId;
                    Flags &= ~EntityFlags.Save;
                }
            }
            else
            {
                PersistentFlags |= MyMwcObjectBuilder_Base.GetDefaultPersistantFlags();
            }

            InitRenderObjects();

            // When entity needs id and has id, add it to list
            if ((Flags & EntityFlags.NeedsId) != 0)
            {
                // When suspended, id is allocated during link
                if (!this.EntityId.HasValue && MyEntityIdentifier.AllocationSuspended == false)
                {
                    this.EntityId = MyEntityIdentifier.AllocateId();
                }

                if (this.EntityId.HasValue)
                {
                    MyEntityIdentifier.AddEntityWithId(this);
                }
            }
            else
            {
                this.EntityId = null;
            }

            this.DisplayName = displayName != null ? displayName.ToString() : null;

            UpdateHudMarker();

            m_worldMatrix = Matrix.Identity;
            //DebugGenerateEntityDisplayName();
            if (!MyFakes.MWBUILDER)
            {
                Debug.Assert(IsActivatedForDifficulty(MyGameplayDifficultyEnum.EASY) || IsActivatedForDifficulty(MyGameplayDifficultyEnum.NORMAL) || IsActivatedForDifficulty(MyGameplayDifficultyEnum.HARD));
            }
        }

        public virtual void UpdateHudMarker(bool enableReset = false) 
        {
            if (DisplayOnHud)
            {
                // we want set hud marker only when entity has no HUD marker (because sometimes we set hud, before activating or activating is buffered etc)
                if (enableReset || !MyHud.ContainsEntity(this))
                {
                    SetHudMarker();
                }
            }
            else 
            {
                MyHud.RemoveText(this);
            }
        }

        protected virtual void SetHudMarker()
        {
            if (!string.IsNullOrEmpty(this.DisplayName) && this.DisplayName != this.GetType().Name)
            {
                var flags = MyHud.DEFAULT_FLAGS;
                if(ShowOnHudOnlyWhenDetected)
                {
                    flags |= MyHudIndicatorFlagsEnum.SHOW_ONLY_IF_DETECTED_BY_RADAR;
                }

                MyHud.ChangeText(this, new StringBuilder(this.DisplayName), null, 0, flags);
            }
        }

        //  This is real initialization of this class!!! Instead of constructor.
        protected void Init(StringBuilder hudLabelText, MyMwcObjectBuilder_Base objectBuilder, MyEntity parentObject)
        {
            Init(hudLabelText, objectBuilder);

            if (parentObject != null)
            {
                parentObject.Children.Add(this);
            }

            MaterialIndex = 0;
        }

        //  This is real initialization of this class!!! Instead of constructor.
        public virtual void Init(StringBuilder displayName, MyModelsEnum? modelLod0Enum, MyModelsEnum? modelLod1Enum,
                                 MyEntity parentObject, float? scale, MyMwcObjectBuilder_Base objectBuilder, MyModelsEnum? modelCollision = null, MyModelsEnum? modelLod2Enum = null)
        {
            Init(displayName, objectBuilder);

            if (modelLod0Enum != null)
            {
                m_modelLod0 = MyModels.GetModelOnlyData(modelLod0Enum.Value);
                LocalVolumeOffset = m_modelLod0.BoundingSphere.Center;
            }
            if (modelLod1Enum != null)
                m_modelLod1 = MyModels.GetModelOnlyData(modelLod1Enum.Value);
            if (modelCollision != null)
                m_modelCollision = MyModels.GetModelOnlyData(modelCollision.Value);
            if (modelLod2Enum != null)
                m_modelLod2 = MyModels.GetModelOnlyData(modelLod2Enum.Value);

            if (m_modelLod0 != null)
            {
                if (m_modelLod1 != null)
                {
                    BoundingBox modelLod1Box = m_modelLod1.BoundingBox;
                    LocalAABB = m_modelLod0.BoundingBox.Include(ref modelLod1Box);
                }
                else
                {
                    this.LocalAABB = m_modelLod0.BoundingBox;
                }
            }
            else
            {   //entities without model has box with side length = 1 by default
                float defaultBoxHalfSize = 0.5f;
                this.LocalAABB = new BoundingBox(new Vector3(-defaultBoxHalfSize), new Vector3(defaultBoxHalfSize));
            }

            if (parentObject != null)
            {
                parentObject.Children.Add(this);
            }

            this.Scale = scale;
        }

        /// <summary>
        /// Every object must have this method, but not every phys object must necessarily have something to cleanup
        /// <remarks>
        /// </remarks>
        /// </summary>
        public virtual void Close()
        {
            //Debug.Assert(MyMinerGame.IsMainThread(), "Entity.Close() called not from Main Thread!");
            Debug.Assert(MyEntities.UpdateInProgress == false, "Do not close entities directly in Update*, use MarkForClose() instead");
            Debug.Assert(MyEntities.CloseAllowed == true, "Use MarkForClose()");
            Debug.Assert(!Closed, "Close() called twice!");

            OnPositionChanged = null;

            MyScriptWrapper.OnEntityClosing(this);
            CallAndClearOnClosing();

            MyEditor.Static.RemoveFromObjectGroups(this);            
            MyDecals.RemoveModelDecals(this);            
            MyEntities.RemoveName(this);
            MyEntities.RemoveFromClosedEntities(this);
            
            if (Physics != null && Physics.Enabled)
            {
                Physics.Enabled = false;
                Physics.RemoveAllElements();
                Physics.Close();
                Physics = null;
            }

            if (Parent == null) //only root objects are in entities list
                MyEntities.Remove(this);
            else
            {
                Parent.Children.Remove(this);  
                /* //TODO: Povolit az budou vyhozeny storkoviny (Observable collection a 
                //Test for last item to faster removal
                if (Parent.Children[Parent.Children.Count - 1] == this)
                    Parent.Children.RemoveAt(Parent.Children.Count - 1);
                else
                    Parent.Children.Remove(this);  
                 */

                if (NeedsUpdate)
                    MyEntities.UnregisterForUpdate(this);

                NotifyRemovedFromScene(null);
                MyEntities.RaiseEntityRemove(this);
            }

            //Children has to be cleared after close notification is send
            while (this.Children.Count > 0)
            {
                MyEntity entToRemove = this.m_children[this.m_children.Count - 1];
                //TODO: Cannot uncomment because of storkoviny. Start new story and kill yourself. Then reload.
                //Debug.Assert(entToRemove.Parent != null, "Entity has no parent but is part of children collection");
                
                entToRemove.Close();
                // TODO: Cannot remove because of storkoviny!
                this.Children.Remove(entToRemove);
            }

            if (this.EntityId.HasValue)
            {
                MyEntityIdentifier.RemoveEntity(this.EntityId.Value);
            }

            this.EntityId = null;
            Debug.Assert(this.Children.Count == 0);

            MyScriptWrapper.OnEntityClose(this);
            CallAndClearOnClose();

            Closed = true;
            Debug.Assert(!MyEntities.m_entitiesForUpdate.Contains(this));
        }

        /// <summary>
        /// This method marks this entity for close which means, that Close
        /// will be called after all entities are updated
        /// </summary>
        public virtual void MarkForClose()
        {
            // Needs update = false, added, because entities was updated once before closed
            NeedsUpdate = false;
            MyEntities.MarkForClose(this);
            if (OnMarkForClose != null)
            {
                OnMarkForClose(this);
            }
        }

        protected void CallAndClearOnClose()
        {
            if (OnClose != null)
                OnClose(this);

            OnClose = null;
        }

        protected void CallAndClearOnClosing() 
        {
            if (OnClosing != null)
                OnClosing(this);

            OnClosing = null;
        }

        /// <summary>
        /// Gets proper object builder and assigns other base properties (EntityId etc.) from MyEntity class
        /// </summary>
        /// <param name="getCopy">
        /// Exact copy - entity will have same EntityID
        /// Value indication whether get exact copy of object or just the same object with different id.
        /// Set to true for example when saving object to database.
        /// </param>
        /// <returns></returns>
        public MyMwcObjectBuilder_Base GetObjectBuilder(bool getExactCopy)
        {
            var result = GetObjectBuilderInternal(getExactCopy);
            if (result != null)
            {
                if (getExactCopy && this.EntityId.HasValue)
                {
                    result.EntityId = this.EntityId.Value.NumericValue;
                    result.Name = this.Name;
                }
                else
                {
                    result.EntityId = null;
                    result.Name = null;
                }

                result.PersistentFlags = PersistentFlags;
            }

            return result;
        }

        /// <summary>
        /// Returns whether object builder is not null.
        /// </summary>
        /// <returns></returns>
        public bool HasObjectBuilder()
        {
            return m_objectBuilder != null;
        }

        /// <summary>
        /// Gets object builder from object.
        /// </summary>
        /// <returns></returns>
        protected virtual MyMwcObjectBuilder_Base GetObjectBuilderInternal(bool getExactCopy)
        {
            if (m_objectBuilder is MyMwcObjectBuilder_Object3dBase)
            {
                var builder = m_objectBuilder as MyMwcObjectBuilder_Object3dBase;
                builder.PositionAndOrientation.Position = this.GetPosition();
                builder.PositionAndOrientation.Up = this.GetOrientation().Up;
                builder.PositionAndOrientation.Forward = this.GetOrientation().Forward;

                //return m_objectBuilder;
            }

            if (m_objectBuilder != null)
            {
                m_objectBuilder.Name = Name;
            }

            return m_objectBuilder;
        }

        /// <summary>
        /// Called before method GetObjectBuilder, when saving sector
        /// </summary>
        public virtual void BeforeSave()
        {

        }

        #region Body Methods
        protected void InitSpherePhysics(MyMaterialType materialType, Vector3 sphereCenter, float sphereRadius, float mass, float angularDamping, ushort collisionLayer, RigidBodyFlag rbFlag)
        {
            UseKinematicPhysics = (rbFlag & RigidBodyFlag.RBF_KINEMATIC) != 0;

            MyPhysicsObjects physobj = MyPhysics.physicsSystem.GetPhysicsObjects();
            MyRBSphereElementDesc sphereDesc = physobj.GetRBSphereElementDesc();
            sphereDesc.SetToDefault();
            sphereDesc.m_RBMaterial = MyMaterialsConstants.GetMaterialProperties(materialType).PhysicsMaterial;
            sphereDesc.m_Radius = sphereRadius;
            sphereDesc.m_Matrix.Translation = sphereCenter;
            sphereDesc.m_CollisionLayer = collisionLayer;

            MyRBSphereElement sphereEl = (MyRBSphereElement)physobj.CreateRBElement(sphereDesc);
            System.Diagnostics.Debug.Assert(sphereEl != null);
            if (sphereEl != null)
            {
                System.Diagnostics.Debug.Assert(Physics == null || !Physics.Enabled);
                // Remove object from physics
                if (Physics != null && Physics.Enabled)
                {
                    Physics.Enabled = false;
                    Physics.RemoveAllElements();
                    Physics.Close();
                    Physics = null;
                }
                
                this.Physics = new MinerWars.AppCode.Game.Physics.MyPhysicsBody(this, mass, rbFlag)
                {
                    MaterialType = materialType,
                    AngularDamping = angularDamping
                };                

                this.Physics.AddElement(sphereEl, true);
            }
        }

        public void InitSpherePhysics(MyMaterialType materialType, MyModel model, float mass, float angularDamping, ushort collisionLayer, RigidBodyFlag rbFlag)
        {
            Debug.Assert(model != null);
            InitSpherePhysics(materialType, model.BoundingSphere.Center, model.BoundingSphere.Radius, mass, angularDamping, collisionLayer, rbFlag);
        }

        public void InitTrianglePhysics(MyMaterialType materialType, float mass, MyModel modelCollision, MyModel modelLOD0, ushort? collisionLayer = null, bool enable = true)
        {
            MyPhysicsObjects physobj = MyPhysics.physicsSystem.GetPhysicsObjects();
            MyRBTriangleMeshElementDesc trianglemeshDesc = physobj.GetRBTriangleMeshElementDesc();
            trianglemeshDesc.SetToDefault();

			if (modelCollision != null)
			{
            	trianglemeshDesc.Model = modelCollision;
			}
            if (modelLOD0 != null) 
            {
                trianglemeshDesc.ModelLOD0 = modelLOD0;
            }

            trianglemeshDesc.m_RBMaterial = MyMaterialsConstants.GetMaterialProperties(materialType).PhysicsMaterial;
            if (collisionLayer != null)
            {
                trianglemeshDesc.m_CollisionLayer = collisionLayer.Value;
            }

            //trianglemeshDesc.m_Matrix.Translation = ModelLod0.BoundingSphere.Center;
        
            MyRBTriangleMeshElement trEl = (MyRBTriangleMeshElement)physobj.CreateRBElement(trianglemeshDesc);
            System.Diagnostics.Debug.Assert(trEl != null);

            // Base rigid body is used to hold static prefabs
            this.Physics = new MyPhysicsBody(this, mass, RigidBodyFlag.RBF_RBO_STATIC) { MaterialType = materialType };

            if (collisionLayer != null)
            {
                this.Physics.CollisionLayer = collisionLayer.Value;
            }

            if (enable && Activated)
            {
                this.Physics.Enabled = true;
            }

            this.Physics.AddElement(trEl, true);
        }

        public void InitBoxPhysics(MyMaterialType materialType, Vector3 center, Vector3 size, float mass, float angularDamping, ushort collisionLayer, RigidBodyFlag rbFlag)
        {
            UseKinematicPhysics = (rbFlag & RigidBodyFlag.RBF_KINEMATIC) != 0;

            MyPhysicsObjects physobj = MyPhysics.physicsSystem.GetPhysicsObjects();

            MyRBBoxElementDesc boxDesc = physobj.GetRBBoxElementDesc();
            boxDesc.SetToDefault();
            boxDesc.m_RBMaterial = MyMaterialsConstants.GetMaterialProperties(materialType).PhysicsMaterial;
            boxDesc.m_Size = size;
            boxDesc.m_Matrix.Translation = center;
            boxDesc.m_CollisionLayer = collisionLayer;

            MyRBBoxElement boxEl = (MyRBBoxElement)physobj.CreateRBElement(boxDesc);
            System.Diagnostics.Debug.Assert(boxEl != null);
            if (boxEl != null)
            {
                //System.Diagnostics.Debug.Assert(Physics == null || !Physics.Enabled);
                // Remove object from physics
                if (Physics != null && Physics.Enabled)
                {                    
                    Physics.Enabled = false;
                    Physics.RemoveAllElements();
                    Physics.Close();
                    Physics = null;
                }

                // Create new physics
                this.Physics = new MinerWars.AppCode.Game.Physics.MyPhysicsBody(this, mass, rbFlag)
                {
                    MaterialType = materialType,
                    AngularDamping = angularDamping
                };                

                this.Physics.AddElement(boxEl, true);
            }
        }

        public void InitBoxPhysics(MyMaterialType materialType, MyModel model, float mass, float angularDamping, ushort collisionLayer, RigidBodyFlag rbFlag)
        {
            Debug.Assert(model != null);
            var center = model.BoundingBox.GetCenter();
            var size = model.BoundingBoxSize;
            InitBoxPhysics(materialType, center, size, mass, angularDamping, collisionLayer, rbFlag);
        }

        #endregion

        /// <summary>
        /// SetSelectedColor
        /// </summary>
        /// <param name="vctColor"></param>
        public virtual void HighlightEntity(ref Vector3 vctColor)
        {
            m_selectionHighlightColor = vctColor;
            this.SetHighlightColor(m_selectionHighlightColor + m_collisionHighlightColor);

            if (IsSelectableParentOnly() == false)
            {
                for (int i = 0; i < this.m_children.Count; i++)
                {
                    this.m_children[i].HighlightEntity(ref vctColor);
                }
            }
        }

        public void ChangeHUDDisplayStatus(MyGuitargetMode targetMode, float distance, MyHudIndicatorFlagsEnum indicatorFlags)
        {
            MyHud.ChangeText(this, new StringBuilder(this.DisplayName), targetMode, distance, indicatorFlags);
        }

        public virtual void DrawMouseOver(ref Vector3 highlightColor)
        {
            BoundingBox aabb = WorldAABB;
            Matrix mat = Matrix.Identity;
            MySimpleObjectDraw.DrawWireFramedBox(ref mat, ref aabb, ref m_mouseOverColorWire, 0.01f, 1);

            this.HighlightEntity(ref highlightColor);
        }

        /// <summary>
        /// Clearhighlightning
        /// </summary>
        public virtual void ClearHighlightning()
        {
            m_selectionHighlightColor = Vector3.Zero;
            this.SetHighlightColor(m_selectionHighlightColor + m_collisionHighlightColor);

            if (IsSelectableParentOnly() == false)
            {
                for (int i = 0; i < this.m_children.Count; i++)
                {
                    this.m_children[i].ClearHighlightning();
                }
            }
        }

        /// <summary>
        /// SetCollisionHighlighting
        /// </summary>
        public virtual void SetCollisionHighlighting(ref Vector3 vctColor)
        {

            m_collisionHighlightColor = vctColor;
            this.SetHighlightColor(m_selectionHighlightColor + m_collisionHighlightColor);

        }

        /// <summary>
        /// IsSelectable
        /// </summary>
        /// <returns></returns>
        public virtual bool IsSelectable()
        {
            return MyEntities.IsSelectable(this);
        }

        /// <summary>
        /// When selecting children component(this), ask weather it can be selected separately
        /// without selecting and highlighting its parent
        /// </summary>
        /// <returns></returns>
        public virtual bool IsSelectableAsChild()
        {
            return false;
        }

        /// <summary>
        /// When selected parent component(this), ask weather its children components will be
        /// selected and highlighted too
        /// </summary>
        /// <returns></returns>
        public virtual bool IsSelectableParentOnly()
        {
            return false;
        }

        /// <summary>
        /// Return default max health from gaemplay constants
        /// </summary>
        /// <returns></returns>
        public float GetDefaultMaxHealth()
        {
            return m_gameplayProperties.MaxHealth;
        }

        public void DumpErrorModels()
        {
            float allowedMaxRatio = 0.25f;
            int allowedMinimum = 50;

            Vector3 wrongModelColor = new Vector3(1, 0, 0);

            //Check on invalid models
            if (m_modelLod1 != null && m_modelLod0 != null)
            {
                if (m_modelLod1.GetTrianglesCount() > m_modelLod0.GetTrianglesCount() * allowedMaxRatio)
                {
                    MyMwcLog.WriteLine("ERROR: Improper LOD1 model in the game: " + m_modelLod1.AssetName + " (too many triangles[" + m_modelLod1.GetTrianglesCount().ToString() + "/" + m_modelLod0.GetTrianglesCount().ToString() + "])");
                    m_modelLod1 = null;
                    if (MyFakes.HIGHLIGHT_WRONG_MODELS)
                        HighlightEntity(ref wrongModelColor);
                }
            }
            //Check on invalid models
            if (m_modelLod2 != null && m_modelLod0 != null)
            {
                if (m_modelLod2.GetTrianglesCount() > m_modelLod0.GetTrianglesCount() * allowedMaxRatio)
                {
                    MyMwcLog.WriteLine("ERROR: Improper LOD2 model in the game: " + m_modelLod2.AssetName + " (too many triangles[" + m_modelLod2.GetTrianglesCount().ToString() + "/" + m_modelLod0.GetTrianglesCount().ToString() + "])");
                    m_modelLod2 = null;
                    if (MyFakes.HIGHLIGHT_WRONG_MODELS)
                        HighlightEntity(ref wrongModelColor);
                }
            }

            bool hasTriangleCollision = false;
            if (Physics != null && Physics.RigidBody != null)
            {
                foreach (MyRBElement rbe in Physics.RigidBody.GetRBElementList())
                {
                    if (rbe is MyRBTriangleMeshElement)
                    {
                        hasTriangleCollision = true;
                        break;
                    }
                }
            }

            if (hasTriangleCollision)
            {
                //Check on invalid models
                if (m_modelCollision != null && m_modelLod0 != null)
                {
                    if ((m_modelCollision.GetTrianglesCount() > m_modelLod0.GetTrianglesCount() * allowedMaxRatio) && (m_modelCollision.GetTrianglesCount() > allowedMinimum))
                    {
                        MyMwcLog.WriteLine("ERROR: Improper COL model in the game: " + m_modelCollision.AssetName + " (too many triangles[" + m_modelCollision.GetTrianglesCount().ToString() + "/" + m_modelLod0.GetTrianglesCount().ToString() + "])");
                        if (MyFakes.HIGHLIGHT_WRONG_MODELS)
                            HighlightEntity(ref wrongModelColor);
                    }
                }

                if (m_modelCollision == null && m_modelLod0 != null)
                {
                    MyMwcLog.WriteLine("ERROR: Improper COL model in the game (missing COL): " + m_modelLod0.AssetName + " (too many triangles[" + m_modelLod0.GetTrianglesCount().ToString() + "/" + m_modelLod0.GetTrianglesCount().ToString() + "])");
                    if (MyFakes.HIGHLIGHT_WRONG_MODELS)
                        HighlightEntity(ref wrongModelColor);
                }
            }
        }

        #endregion
    }
}